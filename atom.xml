<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>泽野之乡</title>
  
  
  <link href="https://zhihuzeye.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhihuzeye.github.io/"/>
  <updated>2025-07-28T15:23:03.561Z</updated>
  <id>https://zhihuzeye.github.io/</id>
  
  <author>
    <name>之乎泽野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Next.js 路由系统</title>
    <link href="https://zhihuzeye.github.io/2025/07/28/NextJs-%E8%B7%AF%E7%94%B1/"/>
    <id>https://zhihuzeye.github.io/2025/07/28/NextJs-%E8%B7%AF%E7%94%B1/</id>
    <published>2025-07-28T11:41:39.000Z</published>
    <updated>2025-07-28T15:23:03.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Next-js-路由系统（约定式路由）"><a href="#Next-js-路由系统（约定式路由）" class="headerlink" title="Next.js 路由系统（约定式路由）"></a>Next.js 路由系统（约定式路由）</h1><p>Next.js 的路由系统基于 <strong>约定大于配置</strong> 原则，开发者只需要将页面组件放在特定目录下，即可自动生成对应的路由，无需手动配置路由表。</p><hr><h2 id="路由基本约定"><a href="#路由基本约定" class="headerlink" title="路由基本约定"></a>路由基本约定</h2><ol><li>所有路由文件必须放在 <code>app/</code> 目录下（App Router 模式）。</li><li>每个<strong>文件夹</strong>表示一个 URL 路径段。</li><li>路由页面文件必须命名为 <code>page.tsx</code> 或 <code>page.js</code>。</li><li>每个页面组件将自动作为一个路由。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>app&#x2F;<br>├── page.tsx             → 路由路径 &#x2F;<br>├── about&#x2F;<br>│   └── page.tsx         → 路由路径 &#x2F;about<br>└── contact&#x2F;<br>└── page.tsx         → 路由路径 &#x2F;contact</p><hr><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>使用 <code>[]</code> 包裹文件夹名来创建动态路由参数。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>app&#x2F;<br>└── products&#x2F;<br>└── [productId]&#x2F;<br>└── page.tsx     → 路由路径 &#x2F;products&#x2F;:productId</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// products/[productId]/page.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProductPage</span>(<span class="params">&#123; params &#125;: &#123; params: &#123; productId: <span class="built_in">string</span> &#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Product ID: &#123;params.productId&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套动态路由"><a href="#嵌套动态路由" class="headerlink" title="嵌套动态路由"></a>嵌套动态路由</h2><p>支持多级动态参数结构。<br>app&#x2F;<br>└── products&#x2F;<br>    └── [productId]&#x2F;<br>        ├── page.tsx         → <code>/products/:productId</code><br>        └── [reviewId]&#x2F;<br>            └── page.tsx     → <code>/products/:productId/:reviewId</code></p><h3 id="捕获所有路由段（Catch-All-Routes）"><a href="#捕获所有路由段（Catch-All-Routes）" class="headerlink" title="捕获所有路由段（Catch-All Routes）"></a>捕获所有路由段（Catch-All Routes）</h3><p>使用 […slug] 语法捕获任意数量的路径段。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>app&#x2F;<br>└── blog&#x2F;<br>    └── […slug]&#x2F;<br>        └── page.tsx         → <code>/blog/*</code> 动态匹配所有子路径</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blog/12</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">CatchAllPage</span>(<span class="params">&#123; params &#125;: &#123; params: &#123; slug: <span class="built_in">string</span>[] &#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>路径段: &#123;params.slug.join(&#x27; / &#x27;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404-页面（Not-Found）"><a href="#404-页面（Not-Found）" class="headerlink" title="404 页面（Not Found）"></a>404 页面（Not Found）</h2><p>全局 404 页面<br>app&#x2F;not-found.tsx</p><p>你也可以为每个路由子目录创建局部 404 页面：<br>app&#x2F;<br>└── about&#x2F;<br>    ├── not-found.tsx<br>    └── page.tsx</p><p>在 not-found.tsx 中定义页面不存在时的 UI：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">NotFound</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>此页面不存在<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主动触发 404</strong><br>你可以通过 notFound() 方法主动触发 404：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; notFound &#125; <span class="keyword">from</span> <span class="string">&#x27;next/navigation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">&#123; params &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="title function_">notFound</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正常页面内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有文件夹（下划线命名）"><a href="#私有文件夹（下划线命名）" class="headerlink" title="私有文件夹（下划线命名）"></a>私有文件夹（下划线命名）</h2><p>使用下划线 _ 开头的文件夹（如 _components&#x2F;）不会被视为路由路径。</p><ul><li>通常用于存放共享组件、工具函数、布局模板等。</li><li>如果确实需要使用下划线路径（不推荐），需通过 %5f URL 编码。</li></ul><h2 id="路由分组（Route-Groups）"><a href="#路由分组（Route-Groups）" class="headerlink" title="路由分组（Route Groups）"></a>路由分组（Route Groups）</h2><p>使用 括号 () 包裹文件夹名 创建逻辑上的路由分组，不影响实际 URL 路径结构。</p><p>app&#x2F;<br>└── (auth)&#x2F;<br>    └── login&#x2F;<br>        └── page.tsx     → <code>/login</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th>功能</th><th>语法&#x2F;文件名</th><th>示例路径</th></tr></thead><tbody><tr><td>静态路由</td><td>page.tsx</td><td>&#x2F;about</td></tr><tr><td>动态路由</td><td>[id]&#x2F;page.tsx</td><td>&#x2F;products&#x2F;123</td></tr><tr><td>嵌套路由</td><td>子目录结构</td><td>&#x2F;products&#x2F;123&#x2F;reviews&#x2F;1</td></tr><tr><td>捕获全部路由</td><td>[…slug]</td><td>&#x2F;blog&#x2F;a&#x2F;b&#x2F;c</td></tr><tr><td>404 页面</td><td>not-found.tsx</td><td>&#x2F;about&#x2F;not-found.tsx</td></tr><tr><td>路由分组</td><td>(group)&#x2F;</td><td>&#x2F;login from (auth)&#x2F;login</td></tr><tr><td>私有目录</td><td>_components&#x2F;</td><td>不作为路由路径</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Next-js-路由系统（约定式路由）&quot;&gt;&lt;a href=&quot;#Next-js-路由系统（约定式路由）&quot; class=&quot;headerlink&quot; title=&quot;Next.js 路由系统（约定式路由）&quot;&gt;&lt;/a&gt;Next.js 路由系统（约定式路由）&lt;/h1&gt;&lt;p&gt;Ne</summary>
      
    
    
    
    
    <category term="Next.js" scheme="https://zhihuzeye.github.io/tags/Next-js/"/>
    
    <category term="路由" scheme="https://zhihuzeye.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
    <category term="前端" scheme="https://zhihuzeye.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://zhihuzeye.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序关联服务号发送模板消息</title>
    <link href="https://zhihuzeye.github.io/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/"/>
    <id>https://zhihuzeye.github.io/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/</id>
    <published>2025-07-09T09:37:03.000Z</published>
    <updated>2025-07-09T09:50:08.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序关联服务号发送模板消息全流程"><a href="#微信小程序关联服务号发送模板消息全流程" class="headerlink" title="微信小程序关联服务号发送模板消息全流程"></a>微信小程序关联服务号发送模板消息全流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于微信小程序模板消息有行业限制，且长期模板申请门槛较高，因此在某些业务场景下，使用小程序自身模板消息并不灵活。</p><p>针对这种情况，可以通过“微信开放平台”关联小程序与服务号的方式，由服务号代替小程序发送模板消息，从而实现消息通知。</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>要实现小程序与服务号的消息打通，必须完成以下认证操作：</p><ol><li><strong>微信服务号认证</strong>：费用 ¥300 &#x2F; 年；</li><li><strong>微信小程序认证</strong>：费用 ¥300 &#x2F; 年；</li><li><strong>微信开放平台认证</strong>：费用 ¥300 &#x2F; 年。</li></ol><p>⚠️ 注意：三个认证缺一不可。</p><h2 id="微信开放平台绑定操作"><a href="#微信开放平台绑定操作" class="headerlink" title="微信开放平台绑定操作"></a>微信开放平台绑定操作</h2><ol><li>登录 <a href="https://open.weixin.qq.com/">微信开放平台</a>，完成认证；</li><li>在“账号管理”中，绑定你的 <strong>微信小程序</strong> 和 <strong>服务号</strong>。</li></ol><p>绑定成功后，两个账号将共享同一 <strong>UnionID</strong>，可实现用户身份互通。</p><p><img src="/images/WX20250709-174425@2x.png" alt="开放平台绑定示意图"></p><h2 id="核心流程详解"><a href="#核心流程详解" class="headerlink" title="核心流程详解"></a>核心流程详解</h2><ol><li>用户在<strong>小程序</strong>中登录，获取 <strong>UnionID</strong>；</li><li>通过 UnionID 查询对应的 <strong>服务号 openid</strong>；</li><li>服务号根据 openid，调用消息推送接口发送模板消息。</li></ol><p>流程图如下：</p><p><img src="/images/sj112sadad1.png" alt="核心流程图解"></p><h2 id="核心接口文档参考"><a href="#核心接口文档参考" class="headerlink" title="核心接口文档参考"></a>核心接口文档参考</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">微信小程序 UnionID 机制说明</a></li><li><a href="https://developers.weixin.qq.com/doc/service/api/usermanage/userinfo/api_batchuserinfo.html">微信服务号 批量获取用户基本信息接口</a></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过微信开放平台绑定小程序与服务号，并结合 UnionID 机制，可以灵活实现小程序与服务号间的消息互通。<br>这种方式适合对消息通知有较高需求的应用场景，是微信官方推荐的解决方案之一。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小程序关联服务号发送模板消息全流程&quot;&gt;&lt;a href=&quot;#微信小程序关联服务号发送模板消息全流程&quot; class=&quot;headerlink&quot; title=&quot;微信小程序关联服务号发送模板消息全流程&quot;&gt;&lt;/a&gt;微信小程序关联服务号发送模板消息全流程&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微信消息推送的几种方式</title>
    <link href="https://zhihuzeye.github.io/2025/07/02/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://zhihuzeye.github.io/2025/07/02/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2025-07-02T02:36:47.000Z</published>
    <updated>2025-07-02T03:44:34.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信消息推送的几种方式"><a href="#微信消息推送的几种方式" class="headerlink" title="微信消息推送的几种方式"></a>微信消息推送的几种方式</h1><h2 id="一、推送方式及对比"><a href="#一、推送方式及对比" class="headerlink" title="一、推送方式及对比"></a>一、推送方式及对比</h2><p>微信平台支持多种消息推送方式，主要包括以下三种：</p><table><thead><tr><th>推送方式</th><th>使用平台</th><th>消息类型</th><th>用户接受程度</th></tr></thead><tbody><tr><td>小程序推送</td><td>微信小程序</td><td>模板消息 &#x2F; 服务通知</td><td>★★★★★（强提醒）</td></tr><tr><td>服务号推送</td><td>微信服务号</td><td>模板消息</td><td>★★★★☆</td></tr><tr><td>公众号推送</td><td>微信订阅号</td><td>图文消息 &#x2F; 通知</td><td>★★★☆☆</td></tr></tbody></table><blockquote><p>✅ <strong>通知强提醒等级排序：服务通知 &gt; 服务号 &gt; 公众号</strong></p></blockquote><hr><h2 id="二、推送效果截图"><a href="#二、推送效果截图" class="headerlink" title="二、推送效果截图"></a>二、推送效果截图</h2><h3 id="1-服务通知截图"><a href="#1-服务通知截图" class="headerlink" title="1. 服务通知截图"></a>1. 服务通知截图</h3><p><img src="/images/WechatIMG406.jpg" alt="服务通知示例"></p><hr><h3 id="2-服务号通知截图"><a href="#2-服务号通知截图" class="headerlink" title="2. 服务号通知截图"></a>2. 服务号通知截图</h3><p><img src="/images/WechatIMG407.jpg" alt="服务号示例"></p><hr><h3 id="3-公众号通知截图"><a href="#3-公众号通知截图" class="headerlink" title="3. 公众号通知截图"></a>3. 公众号通知截图</h3><p><img src="/images/WechatIMG408.jpg" alt="公众号示例"></p><hr><h2 id="三、小程序消息推送说明"><a href="#三、小程序消息推送说明" class="headerlink" title="三、小程序消息推送说明"></a>三、小程序消息推送说明</h2><p>小程序支持不同类型的消息模板推送，其模板分类与使用要求如下：</p><h3 id="小程序模板分类说明"><a href="#小程序模板分类说明" class="headerlink" title="小程序模板分类说明"></a>小程序模板分类说明</h3><table><thead><tr><th>类型</th><th>类目要求</th><th>使用限制</th></tr></thead><tbody><tr><td>新版一次性订阅消息</td><td>仅支持电商等特定类目</td><td>用户订阅后可发送 1 条消息，<strong>无时间限制</strong></td></tr><tr><td>一次性订阅消息</td><td>一般类目均可使用</td><td>同上</td></tr><tr><td>长期订阅消息</td><td>仅限政务民生、医疗、教育等公共服务类目</td><td>当前使用方式未公开</td></tr><tr><td>设备订阅消息</td><td>公共服务类目，需接入硬件设备支持</td><td>每日对单一用户可发送 1 条消息</td></tr></tbody></table><blockquote><p>📌 <strong>说明</strong>：新版模板会优先出现在符合类目要求的小程序的公共模板库中。</p></blockquote><h3 id="模板管理界面示意图"><a href="#模板管理界面示意图" class="headerlink" title="模板管理界面示意图"></a>模板管理界面示意图</h3><p><img src="/images/subscrib.png" alt="小程序订阅模板示意"></p><hr><h3 id="小程序推送使用场景说明"><a href="#小程序推送使用场景说明" class="headerlink" title="小程序推送使用场景说明"></a>小程序推送使用场景说明</h3><ul><li><p><strong>基础订阅场景</strong><br>用户每完成一次订阅授权，开发者即可下发一条消息，<strong>没有时间限制</strong>。即使订阅与实际推送之间间隔很久，也不会失效。</p></li><li><p><strong>支付关联场景</strong><br>用户在小程序内完成微信支付后，开发者可基于支付订单触发<strong>服务通知</strong>，每笔订单最多可下发 <strong>3 条消息</strong>，该额度与普通订阅消息互不冲突。</p></li></ul><hr><h2 id="四、公众号消息推送说明"><a href="#四、公众号消息推送说明" class="headerlink" title="四、公众号消息推送说明"></a>四、公众号消息推送说明</h2><h3 id="公众号消息类型对比"><a href="#公众号消息类型对比" class="headerlink" title="公众号消息类型对比"></a>公众号消息类型对比</h3><table><thead><tr><th>公众号类型</th><th>模板消息支持</th><th>限制条件</th></tr></thead><tbody><tr><td>订阅号</td><td>❌ 不支持模板消息</td><td>仅支持图文或图文卡片消息</td></tr><tr><td>服务号</td><td>✅ 支持模板消息</td><td>需企业或组织认证</td></tr></tbody></table><blockquote><p>💡 服务号每月可主动向用户推送 <strong>4 条模板消息</strong>，适合企业级服务与重要通知场景。</p></blockquote><hr><h2 id="五、核心流程图"><a href="#五、核心流程图" class="headerlink" title="五、核心流程图"></a>五、核心流程图</h2><p>以下为小程序&#x2F;服务号消息推送核心流程示意图：</p><p><img src="/images/xxts.drawio.png" alt="核心流程图"></p><hr><h2 id="六、总结对比"><a href="#六、总结对比" class="headerlink" title="六、总结对比"></a>六、总结对比</h2><table><thead><tr><th>项目</th><th>小程序订阅消息</th><th>服务号模板消息</th><th>公众号图文推送</th></tr></thead><tbody><tr><td>接收强度</td><td>★★★★★</td><td>★★★★☆</td><td>★★★☆☆</td></tr><tr><td>适用场景</td><td>支付提醒、任务提醒、系统通知等</td><td>用户服务通知</td><td>日常图文传播</td></tr><tr><td>限制</td><td>需用户主动订阅</td><td>企业认证</td><td>用户关注即可</td></tr><tr><td>模板多样性</td><td>模板需符合类目限制</td><td>模板较自由</td><td>图文内容为主</td></tr></tbody></table><hr><p>如需集成微信消息推送，请结合业务所属类目、目标用户行为和提醒紧急程度，选择最合适的推送方式，以实现更高的用户触达率和业务转化效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信消息推送的几种方式&quot;&gt;&lt;a href=&quot;#微信消息推送的几种方式&quot; class=&quot;headerlink&quot; title=&quot;微信消息推送的几种方式&quot;&gt;&lt;/a&gt;微信消息推送的几种方式&lt;/h1&gt;&lt;h2 id=&quot;一、推送方式及对比&quot;&gt;&lt;a href=&quot;#一、推送方式及对</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>安装 vscode SCSS IntelliSense 插件后，$$符号问题</title>
    <link href="https://zhihuzeye.github.io/2025/06/17/%E5%AE%89%E8%A3%85%20vscode%20SCSS%20IntelliSense%20%E6%8F%92%E4%BB%B6%E5%90%8E%EF%BC%8C$$%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
    <id>https://zhihuzeye.github.io/2025/06/17/%E5%AE%89%E8%A3%85%20vscode%20SCSS%20IntelliSense%20%E6%8F%92%E4%BB%B6%E5%90%8E%EF%BC%8C$$%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/</id>
    <published>2025-06-17T02:16:30.000Z</published>
    <updated>2025-06-17T02:21:48.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ul><li>安装了SCSS IntelliSense ，输入 $,再选择，会多一个 $符号，如：   font-size:$$font-size-xs。有没有办法解决？</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>终端输入命令，打开services文件夹 open &#x2F;Users&#x2F;apple&#x2F;.vscode&#x2F;extensions&#x2F;mrmlnc.vscode-scss-0.10.0&#x2F;out&#x2F;unsafe&#x2F;services</li><li>修改 parser.js 文件中的 findDocumentSymbols 方法</li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   async function findDocumentSymbols(document, ast) &#123;</span><br><span class="line">    const symbols = ls.findDocumentSymbols(document, ast);</span><br><span class="line">    const links = await findDocumentLinks(document, ast);</span><br><span class="line">    const result = &#123;</span><br><span class="line">        functions: [],</span><br><span class="line">        imports: convertLinksToImports(links),</span><br><span class="line">        mixins: [],</span><br><span class="line">        variables: []</span><br><span class="line">    &#125;;</span><br><span class="line">    for (const symbol of symbols) &#123;</span><br><span class="line">        const position = symbol.location.range.start;</span><br><span class="line">        const offset = document.offsetAt(symbol.location.range.start);</span><br><span class="line">        if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Variable) &#123;</span><br><span class="line">            result.variables.push(&#123;</span><br><span class="line">                name: symbol.name.replace(&quot;$&quot;, &quot;&quot;), // 关键点</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                value: getVariableValue(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Method) &#123;</span><br><span class="line">            result.mixins.push(&#123;</span><br><span class="line">                name: symbol.name,</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                parameters: getMethodParameters(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Function) &#123;</span><br><span class="line">            result.functions.push(&#123;</span><br><span class="line">                name: symbol.name,</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                parameters: getMethodParameters(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装了SCSS IntelliSense ，输入 $,再选择，会多一个 $符号，如：   font-size:$$fon</summary>
      
    
    
    
    
    <category term="常见问题" scheme="https://zhihuzeye.github.io/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 入门</title>
    <link href="https://zhihuzeye.github.io/2024/09/26/MongoDB-%E5%85%A5%E9%97%A8/"/>
    <id>https://zhihuzeye.github.io/2024/09/26/MongoDB-%E5%85%A5%E9%97%A8/</id>
    <published>2024-09-26T12:33:05.000Z</published>
    <updated>2024-09-26T12:40:47.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装-Homebrew"><a href="#1-安装-Homebrew" class="headerlink" title="1. 安装 Homebrew"></a>1. 安装 Homebrew</h3><p>如果还没有安装 Homebrew，可以使用以下命令安装 Homebrew：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>你可以访问 Homebrew 的 <a href="https://brew.sh/">官方网站</a> 了解更多信息。</p><h3 id="2-使用-Homebrew-安装-MongoDB"><a href="#2-使用-Homebrew-安装-MongoDB" class="headerlink" title="2. 使用 Homebrew 安装 MongoDB"></a>2. 使用 Homebrew 安装 MongoDB</h3><h4 id="a-添加-MongoDB-官方-Homebrew-Tap"><a href="#a-添加-MongoDB-官方-Homebrew-Tap" class="headerlink" title="a. 添加 MongoDB 官方 Homebrew Tap"></a>a. 添加 MongoDB 官方 Homebrew Tap</h4><p>首先，运行以下命令来添加 MongoDB 官方的 Homebrew Tap（软件源）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br></pre></td></tr></table></figure><h4 id="b-安装-MongoDB-社区版"><a href="#b-安装-MongoDB-社区版" class="headerlink" title="b. 安装 MongoDB 社区版"></a>b. 安装 MongoDB 社区版</h4><p>接下来，使用 Homebrew 来安装 MongoDB 社区版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mongodb-community@6.0</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>@6.0</code> 是 MongoDB 的版本号，你可以根据需要替换为其他版本。</p></blockquote><h3 id="3-启动-MongoDB-服务"><a href="#3-启动-MongoDB-服务" class="headerlink" title="3. 启动 MongoDB 服务"></a>3. 启动 MongoDB 服务</h3><p>安装完成后，可以通过 Homebrew 启动 MongoDB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start mongodb/brew/mongodb-community</span><br></pre></td></tr></table></figure><p>这会将 MongoDB 作为 macOS 服务启动，并且会在每次系统启动时自动启动。</p><p>如果你只想手动启动 MongoDB 而不让它自动运行，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure><h3 id="4-检查-MongoDB-是否运行"><a href="#4-检查-MongoDB-是否运行" class="headerlink" title="4. 检查 MongoDB 是否运行"></a>4. 检查 MongoDB 是否运行</h3><p>你可以运行以下命令，查看 MongoDB 服务是否已经成功启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services list</span><br></pre></td></tr></table></figure><p>MongoDB 的状态应该显示为 “started”。</p><h3 id="5-连接-MongoDB"><a href="#5-连接-MongoDB" class="headerlink" title="5. 连接 MongoDB"></a>5. 连接 MongoDB</h3><p>MongoDB 服务器启动后，你可以通过 <code>mongo</code> 命令连接到 MongoDB 的命令行工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>如果一切正常，你现在应该已经连接到 MongoDB 的 shell，可以开始使用数据库了。</p><h3 id="6-停止-MongoDB-服务"><a href="#6-停止-MongoDB-服务" class="headerlink" title="6. 停止 MongoDB 服务"></a>6. 停止 MongoDB 服务</h3><p>如果你需要停止 MongoDB 服务，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services stop mongodb/brew/mongodb-community</span><br></pre></td></tr></table></figure><hr><p>这样，你就可以在 Mac 上成功安装和运行 MongoDB。如果遇到任何问题，请确保 Homebrew 和 MongoDB 的安装路径正确，并查看 Homebrew 提供的安装日志。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-安装-Homebrew&quot;&gt;&lt;a href=&quot;#1-安装-Homebrew&quot; class=&quot;headerlink&quot; title=&quot;1. 安装 Homebrew&quot;&gt;&lt;/a&gt;1. 安装 Homebrew&lt;/h3&gt;&lt;p&gt;如果还没有安装 Homebrew，可以使用以下命</summary>
      
    
    
    
    
    <category term="MongoDB" scheme="https://zhihuzeye.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://zhihuzeye.github.io/2024/06/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zhihuzeye.github.io/2024/06/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2024-06-17T13:14:25.000Z</published>
    <updated>2024-09-26T12:25:30.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识对象"><a href="#认识对象" class="headerlink" title="认识对象"></a>认识对象</h2><ol><li>认识对象<ul><li>对象（object） 是键值对的集合，表示属性和值的映射关系</li><li>对象的语法：k和v之间用冒号分割，每组k:v之间用逗号分割，最后一个k:v对后可以不书写逗号</li><li><strong>属性名是否加引号？：如果对象的属性名不符合JS标识符命名规范，则这个键名必须用引号包裹</strong></li><li><strong>属性的访问：可以用“点语法”访问对象中指定键的值，如果属性名不符合JS标识符命名规范，则必须用方括号的写法来访问；如果属性名以变量形式存储，则必须使用方括号形式</strong></li><li>属性的更改：直接使用赋值运算符对某属性复制即可更改属性</li><li>属性的创建：如果对象本身没有某个属性值，则用点语法赋值时，这个属性就会被创建出来</li><li>属性的删除：如果要删除某个对象的属性，则需要用delete操作符</li></ul></li><li>对象的方法<ul><li>如果某个属性值是函数，则它也被称之为对象的“方法”</li><li>方法也是函数，只不过方法是对象的“函数属性”，它需要对象打点使用</li></ul></li><li>对象的遍历<ul><li>和遍历数组类似，对象也可以被遍历，遍历对象需要使用 for…in….循环</li><li>使用 for…in…循环、Object.keys() 等 可以遍历对象每个键</li></ul></li><li><strong>对象的深浅克隆（面试）</strong><ul><li>基本类型值和引用类型值<ul><li>基本类型值<ul><li>数字、字符串、布尔、undefined、null</li><li>内存中产生新的副本</li><li>比较值是否相等</li></ul></li><li>引用类型值<ul><li>对象、数组等</li><li><strong>内存中不产生新的副本，而是让变量指向同一个对象</strong></li><li><strong>比较内存地址是否相同，即比较是否为同一对象</strong></li></ul></li></ul></li><li>对象也是引用类型值<ul><li>不能通过var obj2 &#x3D; obj1 这样的语法克隆一个对象</li><li>使用 &#x3D;&#x3D; 或者 &#x3D;&#x3D;&#x3D; 进行对象的比较时，比较的是它们是否为内存中的同一个对象，而不是比较值是否相同</li></ul></li><li>浅克隆：只克隆对象的“表层”，如果对象的某些属性值又是引用类型值，则不进行一步克隆它，而是引用它</li><li>对象的深克隆：克隆对象的全貌，无论对象的属性值是否又是引用类型值，都能将它们实现克隆</li><li>和数组的深克隆类似，对象的深克隆需要使用递归</li></ul></li></ol><h2 id="认识函数的的上下文"><a href="#认识函数的的上下文" class="headerlink" title="认识函数的的上下文"></a>认识函数的的上下文</h2><ol><li>什么是上下文<ul><li>函数的上下文：函数中可以使用 this 关键字，它表示函数的上下文</li><li>与中文中“这”类似，函数中的 this 具体指代什么必须通过调用函数时的“前言后语”来判断</li><li><strong>普通函数的上下文是调用使用才能确定的，并且规则很多，但是箭头函数的上下文是定义时候确定的。</strong></li><li><strong>函数的上下文由调用方式决定</strong><ul><li>同一个函数，用不同的形式调用他，则函数的上下文不同</li><li><strong>函数只有被调用的时候，它的上下文才能被确定</strong></li><li>函数的上下文（this关键字）由调用函数的方式决定，function是“运行时上下文”策略</li><li>函数如果不调用，则不能确定函数的上下文</li></ul></li></ul></li><li>6种上下文规则<ul><li><strong>规则1：对象打点调用它的方法函数，则函数的上下文是这个打点的对象</strong><ul><li>对象.方法()</li></ul></li><li><strong>规则2：圆括号直接调用函数，则函数上下文是window对象</strong><ul><li>函数()</li></ul></li><li><strong>规则3：数组（类数组对象）枚举出函数进行调用，上下文是这个数组（类数组对象）</strong><ul><li>数组<a href="">下标</a></li><li>类数组对象<ul><li>什么是类数组对象：所有键名为自然数序列（从0开始），且有length属性的对象</li><li>argument对象是最常见的类数组对象，它是函数的实参列表</li></ul></li></ul></li><li><strong>规则4：IIFE中的函数，上下文是window对象</strong><ul><li>IIFE：立即可执行函数</li><li><code>(function()&#123; ...  &#125;)()</code></li></ul></li><li><strong>规则5：定时器、延时器调用函数，上下文是window对象</strong><ul><li>setInterval(函数,时间)</li><li>setTimeout(函数,时间)</li></ul></li><li><strong>规则6：事件处理函数的上下文是绑定事件的DOM元素</strong><ul><li><code>DOM元素.onclick = function()&#123; ... &#125;</code></li></ul></li></ul></li><li>call和apply (call 呼叫,打电话，apply 应用，申请)<ul><li>call 和 apply 能指定函数的上下文 <ul><li>函数.call(上下文)</li><li>函数.apply(上下文)</li></ul></li><li>call 和 apply 区别<ul><li>只有在函数有参数的时候才能被体现出来</li><li>1、call 要用逗号罗列参数 ；2、apply 要把参数写到数组中</li></ul></li></ul></li><li>上下文规则总结（规则&#x2F;上下文）<ul><li>对象.函数() <ul><li>对象</li></ul></li><li>函数()<ul><li>window</li></ul></li><li>数组<a href="">下标</a> <ul><li>数组</li></ul></li><li>IIFE<ul><li>window</li></ul></li><li>定时器、延时器<ul><li>window</li></ul></li><li>DOM事件处理函数<ul><li>绑定DOM的元素</li></ul></li><li>call 和 apply<ul><li>任意指定</li></ul></li><li>用 new 调用函数<ul><li>秘密创建出的对象</li></ul></li></ul></li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>用new调用函数四布走<ul><li>用 new 调用函数的执行步骤和它的上下文弄清楚</li><li><strong>JS 规定，使用new操作符调用函数会进行“四步走”：</strong><ul><li>1、函数体内会自动创建出一个空白对象</li><li>2、函数的上下文（this）会指向这个对象</li><li>3、函数体内的语句会执行</li><li>4、函数会自动返回上下文对象，即使函数没有return语句</li></ul></li></ul></li><li>构造函数<ul><li>构造函数是一种特殊类型的函数，它在创建对象时被调用。它的主要目的是初始化对象的属性和方法。在JavaScript中，构造函数通常使用关键字<code>class</code>或<code>function</code>定义，并使用<code>new</code>关键字来创建对象。构造函数可以接受参数，这些参数可以用于设置对象的属性。</li></ul></li><li>类和实例<ul><li>类好比是“蓝图”，类只描述对象会拥有哪些属性和方法，但是并不具体指明属性的值。</li><li>实例是具体的对象</li><li>JavaScript中的构造函数可以类比于OO语言中的“类”，写法的确类似，但和真正的OO语言还是有本质的不同</li></ul></li></ol><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ol><li>继承<ul><li>实现继承的关键在于：子类必须拥有父类的全部属性和方法，同时子类还能定义自己特有的属性和方法。</li><li>1、原型链继承<ul><li>使用方法：<ul><li>子类的 prototype （原型） &#x3D;  new 父类()</li><li><strong>让子类的构造函数的 prototype ，指向父类的一个实例</strong></li><li>使用 Javascript 特有的原型链特性来实现继承，是普遍的做法</li></ul></li><li>存在的问题：<ul><li>问题2：子类的构造函数中，往往需要重复定义很多超类（父类、基类）定义过的属性，即，子类的构造函数写的不够优雅</li><li>问题1：如果父类的属性中有引用类型值，则这个属性会被所有子类的实例共享</li></ul></li><li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li>2、构造函数继承（伪造对象、经典继承）<ul><li>使用方法：<ul><li><code>Parent.call(this, name);</code></li></ul></li><li>存在的问题：<ul><li><em><strong>借用构造函数的思想非常简单：在子类构造函数的内部调用超类的构造函数，但是要注意使用 call() 绑定上下文</strong></em></li></ul></li><li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>3、组合继承<ul><li>使用方法：<ul><li><code>Parent.call(this, name);</code></li><li><code>Child.prototype = new Parent();</code></li></ul></li><li>存在问题：<ul><li>将借用原型链和借用构造函数的技术组合到一起，叫做组合继承，也叫做伪经典继承</li><li>组合继承是 JavaScript 中最常用的继承方式</li><li>组合继承继承的问题：组合继承最大的问题就是无论在什么情况下，都会调用两次超类的构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数的内部</li><li>构造函数继承和组合继承的区别在于： - 构造函数继承通过在子类构造函数内部调用父类构造函数来实现属性的继承，但无法继承父类原型链上的方法。 - 组合继承则是结合了原型链继承和构造函数继承的优点，通过调用父类构造函数来实现属性的继承，并且通过将子类的原型指向父类的实例来继承父类的方法。</li></ul></li><li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>4、原型式继承<ul><li>使用方法：<ul><li><code>var child = Object.create(parent);</code></li></ul></li><li>存在问题：<ul><li><strong>Object.create() 方法，可以根据指定的对象为原型创建出新对象，兼容性大于IE9</strong></li><li>在没有必要“兴师动众”地创建构造函数，而只是想让新对象与现有对象“类似”的情况下，使用 Object.create() 即可胜任，称为原型式继承</li><li>Object.create() 的兼容性写法<ul><li>如何在低版本浏览器中实现 object.create() 呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个临时构造函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 让这个临时构造函数的 prototype 指向o，这样一来它 new 出来的对象，__prototype__ 指向了o</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">    <span class="comment">// 返回 F 的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">object</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">__proto__</span> === obj1)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">b</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">   <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br></pre></td></tr></table></figure></li></ul></li><li>5、寄生式继承<ul><li>使用方法：<ul><li>编写一个函数，它接收一个参数o，返回以o为原型的新对象p，同时给p上添加预置的新方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;悠悠&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(o)</span><br><span class="line">    p.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，正在睡觉`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">f</span>(o1)</span><br><span class="line">p1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">88</span>)</span><br><span class="line">p1.<span class="title function_">sayHello</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">f</span>(o2)</span><br><span class="line">p2.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p2&quot;</span>,p2)</span><br></pre></td></tr></table></figure></li><li>寄生式继承就是编写一个函数，它可以“增强对象”，只要把对象传入这个函数，这个函数将以此对象为“基础”创建出新对象，并为新对象赋予新的预置方法</li><li>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式</li></ul></li><li>存在问题：<ul><li>缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，即“方法没有写到 prototype 上”</li></ul></li><li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">createChild</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">    child.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi from Child&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">createChild</span>(parent);</span><br></pre></td></tr></table></figure></li></ul></li><li>6、寄生组合式继承<ul><li>使用方法：<ul><li><strong>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已，本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受两个函数，子类构造函数、父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">33</span>, <span class="number">44</span>, <span class="number">56</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello 我是&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;在睡觉&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, sex, age, no, scholl</span>) &#123;</span><br><span class="line">    <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, sex, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">no</span> = no;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scholl</span> = scholl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用我们自己写的 inheritPrototype 函数，让 Student 类的 prototype 指向以 People.prototype 为原型的一个新对象</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">People</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">study</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exam</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">14025123</span>, <span class="string">&#x27;wenzhou&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure></li><li>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</li></ul></li><li>存在问题：<ul><li>寄生组合式继承的主要缺点是： 1. 虽然解决了组合继承中多次调用父类构造函数的问题，但仍然会调用一次父类构造函数来创建原型。 2. 增加了代码的复杂度，相比其他继承方式，可读性较差。</li></ul></li><li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">   prototype.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">   <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>instanceof 运算符<ul><li>用来检测“某个对象”对象是不是某个类的实例</li><li>底层机理：检查 Student.prototype 属性是否在 xiaoming 的原型链上（多少层都是，只要在就行）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming instaceof <span class="title class_">Student</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>原型链的终点<ul><li><em><strong>原型链的终点是 Object.prototype。 Object.prototype 是所有 JavaScript 对象的顶层原型，它是原型链的终点。</strong></em></li></ul></li><li>在prototype上添加方法<ul><li>People.prototype.方法 &#x3D; function(){ … }</li></ul></li><li>prototype在原型链查找<ul><li><strong>Javascript规定：实例可以打点访问它的原型的属性和方法，这被称为“原型链查找”</strong></li><li>遮蔽效应：如果实例上已经有属性和方法，则不往原型链上查找</li></ul></li><li>什么是prototype？<ul><li>任何函数都有prototype属性，prototype是英语“原型”的意思</li><li>prototype 属性值是个对象，它默认拥有 constructor 属性指回函数</li><li><strong>普通函数的 prototype 属性没有任何用处，而构造函数的 prototype 属性非常有用</strong></li><li><em><strong>构造函数的 prototype 属性是它实例的原型</strong></em></li></ul></li><li>hasOwnProperty<ul><li>hasOwnProperty 方法可以检查对象是否真正“自己拥有”某属性或者方法<ul><li>实例.hasOwnProperty(‘属性|方法’)</li></ul></li></ul></li><li>in<ul><li>in 运算符只能检查某个属性或方法是否可以被对象访问，不能检查是否自己的属性或方法<ul><li>语法：’属性|方法’ in 实例</li></ul></li></ul></li></ol><h2 id="上升到面向对象"><a href="#上升到面向对象" class="headerlink" title="上升到面向对象"></a>上升到面向对象</h2><ol><li>面向对象的本质：定义不同的类，让类的实例工作</li><li>面向对象的优点：程序编写更清晰、代码结构更严密、使代码更健壮更利于维护</li><li>面向对象经常用到的场合：需要封装和复用性的场合（组件思维）</li></ol><h2 id="JS的内置对象"><a href="#JS的内置对象" class="headerlink" title="JS的内置对象"></a>JS的内置对象</h2><ol><li>Date对象<ul><li>使用 new Date() 即可得到当前时间的日期对象，它是 object 类型值</li><li>使用 new Date(2020,11,1) 即可得到指定日期的日期对象，注意第二个参数表示月份，从0开始算，11表示12月<ul><li>这种写法不算时区</li></ul></li><li>也可以是 new Date(‘2020-12-01’)  这样的写法，月份，日期不足两位要补零<ul><li>按照字符串的写法，月份不是从0开始算，12月就是12月</li><li>这种写法算时区，中国属于东八区</li></ul></li><li>日期对象的常见方法<ul><li>getDate() 得到日期 1 ~ 31</li><li>getDay()  得到星期 0 ~ 6</li><li>getMonth()  得到月份 0 ~ 11</li><li>getFullYear()  得到年份 </li><li>getHours()  得到小时数 0 ~ 23</li><li>getMinutes()  得到分钟数 0 ~ 59</li><li>getSeconds()  得到秒数 0 ~ 59</li></ul></li><li>时间戳<ul><li>时间戳表示1970年1月1日零点整距离某时刻的毫秒数</li><li>通过 getTime() 方法或者 Date.parse() 函数可以将日期对象变为时间戳<ul><li>getTime() 精确到毫秒</li><li>Date.parse() 精确到秒</li></ul></li><li>通过 new Date(时间戳)  的写法，可以将时间戳变为日期对象</li></ul></li></ul></li><li>包装类<ul><li>Number()、String()、Boolean() 分别是数字、字符串、布尔值的“包装类”</li><li>很多编程语言都有“包装类”的设计，包装类的目的就是为了让基本类型值可以从他们的构造函数的prototype上获得方法</li><li>Number()、String()、Boolean() 的实例都是 object 类型，它们的 PrimitiveValue 属性存储的它们本身值<ul><li>PrimitiveValue 属性不可以自己打点访问，它是一个内部属性值</li></ul></li><li>new 出来的基本类型值可以正常参与运算</li><li>Array 不能成为数组的包装类 ，包装类是对基本类型的面向对象封装，而 Array 本身就不是基本类型值（而是引用类型值），所以就谈不上包装了，undefined、null 是没有包装类的</li></ul></li><li>Math对象<ul><li>幂和开方<ul><li>Math.pow()、Math.sqrt()</li></ul></li><li>向上取整和向下取整<ul><li>Math.ceil()、Math.floor()</li></ul></li><li>四舍五入方法<ul><li>Math.round()</li></ul></li><li>Math.max() 和 Math.min()<ul><li>Math.max() 可以得到参数列表最大值</li><li>Math.min() 可以得到参数列表最小值</li><li>Math.max() 要求参数必须是“罗列出来”，而不能是数组<ul><li>用 ES6 展开运算符</li><li>Math.max.apply(null,arr)</li></ul></li></ul></li><li>随机数 Math.random()<ul><li>Math.random() 可以得到 0 ~ 1之间的小数</li><li>为了得到 [a，b] 区间内的整数，可以使用这个公式 <ul><li><code>parseInt(Math.random() * (b - a + 1))  + a</code></li></ul></li></ul></li></ul></li></ol><h2 id="JS的内置构造函数"><a href="#JS的内置构造函数" class="headerlink" title="JS的内置构造函数"></a>JS的内置构造函数</h2><ol><li>Javascript 有很多内置构造函数，比如Array就是数组的构造函数，Function 就是函数类型的构造函数，Object 就是对象类型的构造函数<ul><li>任何数组的字面量都可以看做是Array的实例</li><li>拓展数组的求和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展求和方法</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            count += arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">sum</span>())</span><br></pre></td></tr></table></figure></li></ul></li><li>内置的构造函数非常有用，所有该类型的方法都是定义在它的内置构造函数的 prototype 上的，我们可以给这个对象添加新的方法，从而拓展某类型的功能</li><li>内置构造函数的关系<ul><li><strong>Object.prototype 是万物原型链的终点。Javascript 中函数、数组皆为对象。</strong></li><li>任何函数都可以看做是 Function “new 出来的”，那我们开一个脑洞：Object 也是函数呀，它是不是 Function “new 出来的呢”？答案是肯定的</li></ul></li></ol><h2 id="重点内容"><a href="#重点内容" class="headerlink" title="** *重点内容 **"></a>** *重点内容 **</h2><ol><li>熟悉每条函数上下文 this 的判定规则<ul><li><strong>函数上下文 this 取决于函数如何被调用，而不是函数如何被定义</strong></li></ul></li><li>call 和 apply 的功能和区别</li><li>用 new 调用函数的四步走</li><li>什么是类和实例？面向对象编程的意义</li><li>prototype 和原型链查找</li><li>继承的实例、有哪些继承的方法？</li><li>使用面向对象实现小案例</li><li>熟练掌握 Math、Date等 JS 内置对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识对象&quot;&gt;&lt;a href=&quot;#认识对象&quot; class=&quot;headerlink&quot; title=&quot;认识对象&quot;&gt;&lt;/a&gt;认识对象&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;认识对象&lt;ul&gt;
&lt;li&gt;对象（object） 是键值对的集合，表示属性和值的映射关系&lt;/li&gt;
&lt;li&gt;对象的</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>流程控制语句</title>
    <link href="https://zhihuzeye.github.io/2024/06/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>https://zhihuzeye.github.io/2024/06/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2024-06-15T14:44:38.000Z</published>
    <updated>2024-09-26T12:25:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ol><li>if 语句的基本使用 <ul><li>如果…..就…..否则</li></ul></li><li>if elseif 多条件分支<ul><li>else if() 条件分支“暗含”不符合之前的所有条件，要深刻理解什么叫“否则如果”</li></ul></li><li>if 语句算法题</li><li>switch 语句<ul><li>用途：当一个变量被分类讨论的情形</li></ul></li><li>三元运算符<ul><li>条件表达式 ? 表达式1 : 表达式2</li><li>三元运算的用途：根据某个条件是否成立，在两个不同值中选择变量的值</li></ul></li></ol><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ol><li>for 循环语句<ul><li>循环通常需要三个参数：起始值、结束值和步长。这些参数可以用for循环来指定。</li></ul></li><li>for 循环算法题<ul><li><em><strong>for循环有明确的范围，while循环没有明确的范围</strong></em></li></ul></li><li>while 循环语句<ul><li>while 语句 也是一种循环结构，是一种“不定范围”循环，和for循环各有不同的勇武之地</li><li>几乎所有编程语言，都提供了for和while语句</li><li><em><strong>while 语句事先不指定循环开始、结束范围，只要测试条件满足，就一直执行循环体</strong></em></li><li>while 循环没有显式定义循环变量，必须自己在while循环外先定义好循环变量，有时甚至可以没有循环变量</li><li>循环体内的语句，必须使循环测试条件趋向不成立，否侧会死循环。</li><li>while 循环，while 是 “当”的意思。</li><li>更适合while循环的场景<ul><li>寻找最小满足n²&gt;456789的整数n</li></ul></li></ul></li><li>break 和 continue <ul><li>break 表示立即终止循环，它只能用在循环语句中，在for循环和while循环中都可以使用</li><li>continue 用于 跳过循环中的一个迭代，并继续执行循环中的下一个迭代。for循环更经常使用continue</li></ul></li><li>do while 语句<ul><li>是一种“后测试循环语句”，它不同于for循环和while循环每次都是“先测试条件是否满足，然后执行循环体”，do-while循环是“先执行循环体，再测试条件是否满足”</li><li>do { 循环体 } while (循环执行条件)</li></ul></li><li>while 语句算法题</li></ol><h2 id="初识算法"><a href="#初识算法" class="headerlink" title="初识算法"></a>初识算法</h2><ol><li>什么是算法<ul><li>指的是解题方案的准确而完整的描述。是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制，也就是说，能够对一定规范的输入，在有限的实际内获得所要求的的输出。</li><li>算法就是把一个问题，拆解成计算机能够一步一步执行的步骤。</li><li>计算机的流程控制语句：顺序执行，选择语句，循环语句。</li><li>优秀算法的要求<ul><li>正确性</li><li>健壮性</li><li>可读性</li></ul></li></ul></li><li>累加器和累乘器</li><li>穷举法</li><li>综合算法题目</li><li>随机数函数<ul><li>得到[a,b]区间的整数，公式：</li><li><code>parseInt(Math.random()* (b-a + 1)) + a</code></li></ul></li></ol><h2 id="如何拆位"><a href="#如何拆位" class="headerlink" title="如何拆位"></a>如何拆位</h2><ol><li>数学方法<ul><li><code>百位是原数字除以100取整  Math.floor(n/100)</code></li><li><code>十位是原数字除以10取整，再与10求模  Math.floor(n/10) % 10</code></li><li><code>个位是原数字与10求模  n % 10</code></li></ul></li><li>字符串方法<ul><li>直接将原数字 变为字符串，然后再用charAt()方法得到每个数位的值</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;if 语句的基本使用 &lt;ul&gt;
&lt;li&gt;如果…..就…..否则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;if </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>定时器和延时器</title>
    <link href="https://zhihuzeye.github.io/2024/06/15/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E5%99%A8/"/>
    <id>https://zhihuzeye.github.io/2024/06/15/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E5%99%A8/</id>
    <published>2024-06-15T14:34:38.000Z</published>
    <updated>2024-09-26T12:25:30.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li>setInterval()  函数可以重复调用一个函数，在每次调用之间具有固定的时间间隔<ul><li>第一个参数是函数</li><li>第二个参数是间隔时间，以毫秒为单位，1000毫秒是1秒</li><li>函数可以接受3，4….个参数，它们将按照顺序传入函数</li><li>具名函数也可以传入serInterval （有名称的函数），但是不能加上括号，不加括号说明传入是 函数，加括号说明是传入执行体（会立即执行，起不到定时执行的效果）</li></ul></li></ol><h2 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h2><ol><li>clearInterval() 函数可以清除定时器，入参传入定时器名称</li></ol><h2 id="延时器"><a href="#延时器" class="headerlink" title="延时器"></a>延时器</h2><ol><li>setTimeout() 函数可以设置一个延时器，当指定时间到了之后，会执行函数一次，不会重复执行</li><li>clearTimeout() 函数可以清除延时器</li></ol><h2 id="初步认识异步语句"><a href="#初步认识异步语句" class="headerlink" title="初步认识异步语句"></a>初步认识异步语句</h2><ol><li>setInterval 和 setTimeout 是两个异步语句</li><li>异步（asynchronous）: 不会阻塞CPU继续执行其它语句，当异步完成时，会执行“回调函数”（callback）</li></ol><h2 id="使用定时器实现动画"><a href="#使用定时器实现动画" class="headerlink" title="使用定时器实现动画"></a>使用定时器实现动画</h2><ol><li>使用定时器实现动画较为不便：<ul><li>1、不方便根据动画总时间计算步长</li><li>2、运动方向要设置正负</li><li>3、多种运动进行叠加较为困难（比如一个放下一边移动一边变为圆形）</li></ul></li></ol><h2 id="JS和CSS3结合实现动画"><a href="#JS和CSS3结合实现动画" class="headerlink" title="JS和CSS3结合实现动画"></a>JS和CSS3结合实现动画</h2><ol><li>CSS3的transition过渡属性可以实现动画</li><li>JavaScript可以使用css3的transtion属性轻松实现元素动画</li><li>JS和CSS3结合实现动画规避了定时器制作动画的缺点</li></ol><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><ol><li>一个函数执行一次后，只有大于设定的执行周期后才允许执行第二次</li><li>函数节流非常容易实现，只需要借助setTimeout()延时器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;setInterval()  函数可以重复调用一个函数，在每次调用之间具有固定的时间间隔&lt;ul&gt;
&lt;li&gt;第一个参数是函</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>表达式与操作符</title>
    <link href="https://zhihuzeye.github.io/2024/06/15/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://zhihuzeye.github.io/2024/06/15/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6/</id>
    <published>2024-06-15T13:21:13.000Z</published>
    <updated>2024-09-26T12:25:30.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS-基本表达式"><a href="#JS-基本表达式" class="headerlink" title="JS 基本表达式"></a>JS 基本表达式</h2><ol><li>算数表达式<ul><li><code>+ 加</code><ul><li>加号有“加法”和“连字符”两种作用</li><li>如果加号两边操作数都是数字，则为“加法”，否则为连字符</li></ul></li><li><code>- 减</code></li><li><code>* 乘</code></li><li><code>/ 除</code></li><li><code>% 取余</code><ul><li>a % b 表示求 a 除以 b 的余数，它不关心整数部分，只关心余数</li></ul></li><li>默认情况，乘除法的优先级要高于加法和减法；必要时可以使用<strong>圆括号</strong>来改变运算的顺序</li><li>隐式类型转换<ul><li>如果参与数学运算的某操作数不是数字型，那么Javascript会自动将此操作数转换为数字型（不包括 加号 运算符）</li><li><code>例：3 * &quot;4&quot; //  12</code></li><li>隐式转换的本质是内部调用 Number() 函数</li></ul></li></ul></li><li>关系表达式<ul><li>大于 &gt;</li><li>小于 &lt;</li><li>大于或等于 &gt;&#x3D;</li><li>小于或等于 &lt;&#x3D;</li><li>等于 &#x3D;&#x3D;</li><li>不等于 !&#x3D;</li><li>全等于 &#x3D;&#x3D;&#x3D;</li><li>不全等于 !&#x3D;&#x3D;</li><li>null 和 undefined 用 &#x3D;&#x3D; 进行比较涉及隐式强制类型转换，ES5规范中规定<ul><li>如果 x 为null ，y为 undefined，则结果为true</li><li>如果x为undefined,y为null，则结果为true</li><li>null 和 undefined 用 &#x3D;&#x3D;&#x3D; 比较时结果为false，是因为类型不同</li><li>typeof null -&gt; object</li><li>typeof undefined -&gt; undefined</li></ul></li><li>NaN 不自等<ul><li>如何判断某个值为 NaN ，isNaN</li></ul></li></ul></li><li>逻辑表达式<ul><li>或<ul><li>|| 有真就真</li></ul></li><li>与<ul><li>&amp;&amp;  都真才真</li></ul></li><li>非<ul><li>! 表示 “非”，也可以称为“置反运算”</li><li>! 是一个“单目运算符”，只需要一个操作数</li><li>置反运算的结果一定是布尔值</li><li><em><strong>!! 两个叹号是将这个值的相应布尔值展现出来</strong></em></li></ul></li><li>短路计算（面试）<ul><li><code>例：3 &amp;&amp; 6 ，结果为 6，  3 || 6 ，结果为 3</code></li></ul></li><li><strong>逻辑运算顺序的优先级是： 非 -&gt;  与 -&gt; 或</strong></li></ul></li><li>赋值表达式<ul><li>赋值  &#x3D;</li><li>快捷赋值<ul><li>+&#x3D;</li><li>-&#x3D;</li><li>*&#x3D;</li><li>&#x2F;&#x3D;</li><li>%&#x3D;</li></ul></li><li>自增运算<ul><li>++</li><li>a++ 先用再加，++a 先加再用</li><li><strong>面试题：var a &#x3D; 3, b&#x3D;4; alert(a++ + b++ + ++a + ++b)</strong></li></ul></li><li>自减运算 –</li></ul></li><li>综合表达式<ul><li><strong>运算顺序：非运算 -&gt; 数学运算 -&gt; 关系运算 -&gt; 逻辑运算</strong></li><li>变量的范围表示<ul><li>例如：验证变量 a 是否介于5到12之间。num1 &gt;&#x3D; 5 &amp;&amp; num1 &lt;&#x3D; 12</li></ul></li></ul></li></ol><h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><ol><li>5  +  3<ul><li>表达式 &#x3D; 操作数 运算符 操作数</li></ul></li></ol><h2 id="有关-IEEE754"><a href="#有关-IEEE754" class="headerlink" title="有关 IEEE754"></a>有关 IEEE754</h2><ol><li>Javascript 使用了 IEEE754 二进制浮点数算数标准，这会使一些个别的小数计算产生“丢失精度”问题</li><li>解决方法：在进行小数运算时候，要调用数字的toFixed()方法保留指定的小数位数</li><li>幂和开根号<ul><li>Javascript 没有提供幂计算、开根号的运算符。需要使用Math对象的相关方法进行计算。</li><li>Math.pow(2,3) 幂计算，2的3次方</li><li>Math.sqrt(81)  开根号运算符</li><li>向上取整  Math.ceil()</li><li>向下取整  Math.floor()</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS-基本表达式&quot;&gt;&lt;a href=&quot;#JS-基本表达式&quot; class=&quot;headerlink&quot; title=&quot;JS 基本表达式&quot;&gt;&lt;/a&gt;JS 基本表达式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;算数表达式&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+ 加&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;加</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 基本数据类型</title>
    <link href="https://zhihuzeye.github.io/2024/06/14/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zhihuzeye.github.io/2024/06/14/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-06-14T11:41:46.000Z</published>
    <updated>2024-09-26T12:25:30.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型简介和检测"><a href="#数据类型简介和检测" class="headerlink" title="数据类型简介和检测"></a>数据类型简介和检测</h2><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol><li>null 类型<ul><li>表示“空”，它是“空对象”</li><li>当我们需要将对象销毁、数组销毁或者删除事件监听时，通常将它们设置为null<ul><li><code>box.click = null</code></li></ul></li><li><strong>使用 typeof 检测 null 值，结果是object，这点尤其要注意</strong></li><li>类型和typeof 检测结果并不是一一对应的，比如数组用typeof检测出来的结果也是object</li></ul></li><li>undefined 类型<ul><li>一个没有被复制的变量的默认值是undefined，而undefine的类型也是undefined</li><li>即：undefined又是值，又是一种类型，这种类型只有它自己一个值</li></ul></li><li>布尔类型  （Boolean）<ul><li>布尔型值只有两个：true 和 fasle，分别表示真和假</li></ul></li><li>字符串类型（String）<ul><li>字符串要用引号包裹，双引号或者单引号均可</li><li>加号可以用来拼接多个字符串</li><li>空字符串，直接写闭合的引号即可</li><li>字符串的 length 属性表示字符串的长度</li><li>字符串的常用方法<ul><li>charAt()<ul><li>得到指定位置字符</li></ul></li><li>substring()<ul><li>提取子串<ul><li>substring(a,b) 方法得到从 a 开始到b结束（不包含b处）的子串</li><li>如果省略第二个参数，返回字符串一直到字符串的结尾</li><li>substring(a,b) 中，a 可以大于 b ，数字顺序将自动调整为小数在前</li></ul></li></ul></li><li>substr()<ul><li>提取子串<ul><li>substr(a,b) 方法得到从 a 开始的 长度为b的子串<ul><li>子串的长度而不是编号</li></ul></li><li>substr(a,b) 方法 b 参数可以省略，表示到文档的结尾</li><li>substr(a,b) 方法中，a可以是负数，表示倒数位置</li></ul></li></ul></li><li>slice()<ul><li>提取子串<ul><li>slice(a,b) 方法得到从 a 开始到b结束（不包含b处）的子串</li><li>slice(a,b) 方法 a 参数可以是负数</li><li>slice(a,b) 方法 a 参数必须小于b</li></ul></li></ul></li><li>toUpperCase()<ul><li>将字符串变为大写</li></ul></li><li>toLowerCase()<ul><li>将字符串变为小写</li></ul></li><li>indexOf()<ul><li>检索字符串<ul><li>返回某个字符串值在首次出现的位置</li><li>如果检测的字符串值没有出现，则返回-1</li></ul></li></ul></li></ul></li></ul></li><li>数字类型（Number）<ul><li>所有数字不分大小、不分整浮、不分正负、都是数字类型</li><li>小数中，零是可以省略的</li><li>较大数或较小数（绝对值比较小），可以写成科学计数法<ul><li>例：3e8、3e-4</li></ul></li><li>不同进制的数字<ul><li>二进制数值以0b开头  例：0b10</li><li>八进制数值以0开头  例：017</li><li>十六进制以0x开头  例如：0x156</li></ul></li><li>一个特殊的数字型值NaN<ul><li>NaN是英语 “not a number” 的 意思，即“不是一个数”，但它是一个数字类型的值</li><li>typeof NaN    &#x2F;&#x2F; number</li><li>0&#x2F;0 的结果就是NaN，事实上，在数学运算中，若结果不能得到数字，其结果往往都是NaN</li><li>NaN有一个“奇怪”的性质，不自等。</li></ul></li></ul></li></ol><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><ol><li>其它值 -&gt; 数值<ul><li>Number() 系统内置的构造函数</li><li>parseInt() 函数</li><li>parseFloat() 函数</li></ul></li><li>其它值 -&gt; 字符串<ul><li>String() 函数 系统内置的构造函数</li><li>toString() 方法，几乎所有的值都有该方法</li><li><em>当数值直接调用 toString() 方法的时候，要加上括号 例：(5).toString()</em></li></ul></li><li>其它值 -&gt; 布尔值<ul><li>Boolean() 函数</li></ul></li></ol><h2 id="复杂数据类型简介"><a href="#复杂数据类型简介" class="headerlink" title="复杂数据类型简介"></a>复杂数据类型简介</h2><ol><li>对象  Object</li><li>方法 Function</li><li>复杂数据类型都是“引用类型”</li></ol><h2 id="typeof-运算符可以检测值或者变量的类型"><a href="#typeof-运算符可以检测值或者变量的类型" class="headerlink" title="typeof 运算符可以检测值或者变量的类型"></a>typeof 运算符可以检测值或者变量的类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">5</span>; </span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;shanmu&quot;</span>;</span><br></pre></td></tr></table></figure><ol><li>typeof 不是内置函数 是操作符</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型简介和检测&quot;&gt;&lt;a href=&quot;#数据类型简介和检测&quot; class=&quot;headerlink&quot; title=&quot;数据类型简介和检测&quot;&gt;&lt;/a&gt;数据类型简介和检测&lt;/h2&gt;&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;head</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS语法与变量</title>
    <link href="https://zhihuzeye.github.io/2024/06/14/JS%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
    <id>https://zhihuzeye.github.io/2024/06/14/JS%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F/</id>
    <published>2024-06-14T11:36:17.000Z</published>
    <updated>2024-09-26T12:25:30.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2><ol><li>alert</li><li>console</li></ol><h2 id="前端开发主要有哪些层，语言和功能是什么？"><a href="#前端开发主要有哪些层，语言和功能是什么？" class="headerlink" title="前端开发主要有哪些层，语言和功能是什么？"></a>前端开发主要有哪些层，语言和功能是什么？</h2><ol><li>HTML<ul><li>结构层  搭建骨架、描述页面语义</li></ul></li><li>CSS<ul><li>样式层</li></ul></li><li>Javascript<ul><li>行为层  表单验证、数据交互、数据收发等</li></ul></li></ol><h2 id="变量声明提升（面试题）"><a href="#变量声明提升（面试题）" class="headerlink" title="变量声明提升（面试题）"></a><strong>变量声明提升（面试题）</strong></h2><ol><li>你可以提前使用一个稍后才声明的变量，而不会引发异常</li><li>在执行所有代码前，JS有预解析阶段，会预读所有变量的定义</li><li>只提升定义，并不提升值</li><li>var 关键词可以变量提升， let 并不能</li><li>在实际开发中，一定要先定义变量赋值，再使用。</li></ol><h2 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么"></a>变量是什么</h2><ol><li>要定义变量，第一步就是声明它，并给它赋值</li><li>变量是计算机语言中能存储计算结果或能表示值抽象概念</li><li>变量不是数值本身，它们仅仅是一个用于存储数值的容器</li><li>标识符的命名规则（函数、类名、对象的属性也要遵守这个规则）<ul><li><strong>变量名大小写敏感，a和A两个不同的变量</strong></li><li><strong>不能是关键词或保留词</strong></li><li><strong>只能由字母、数字、下划线、$组成，但不能以数字开头</strong></li></ul></li><li>优秀的变量命名法<ul><li>驼峰命名法 例如：mathTestScore</li><li>c风格 例如：math_test_score</li><li>匈牙利命名法 例如：iMathTestScore ，第一个字母 i，提示变量类型</li></ul></li><li>变量的默认值<ul><li>一个变量只定义，但没有赋值，默认是undefined</li></ul></li><li>等号表示赋值</li><li>同时声明多个变量<ul><li>var a&#x3D;0,b&#x3D;0;</li></ul></li><li>var 定义的变量会被挂载在 window 上，let 不会</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;输出语句&quot;&gt;&lt;a href=&quot;#输出语句&quot; class=&quot;headerlink&quot; title=&quot;输出语句&quot;&gt;&lt;/a&gt;输出语句&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;alert&lt;/li&gt;
&lt;li&gt;console&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;前端开发主要有哪些层，语言和</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS函数与DOM</title>
    <link href="https://zhihuzeye.github.io/2024/06/14/JS%E5%87%BD%E6%95%B0%E4%B8%8EDOM/"/>
    <id>https://zhihuzeye.github.io/2024/06/14/JS%E5%87%BD%E6%95%B0%E4%B8%8EDOM/</id>
    <published>2024-06-14T11:08:46.000Z</published>
    <updated>2024-09-26T12:25:30.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h2><ol><li>函数的参数和返回值<ul><li>参数可多可少，用逗号分开</li><li>函数体内可以使用 return 关键词表示 “函数的返回值”</li><li>调用一个有返回值的函数，可以被当做一个普通纸，从而可以出现在哪任何可以书写值的地方</li><li>调用函数时，一旦遇见 return 语句则会立即退出函数，将执行权还给调用者</li></ul></li><li>函数的定义和调用<ul><li>和变量相似，函数必须先定义然后才能使用</li><li>使用 function 关键词定义函数，function 是“功能”的意思</li><li>函数名，必须符合JS标识符的命名规则</li></ul></li><li>什么是函数<ul><li>函数就是语句的封装，可以让这些代码方便的被复用</li><li>函数具有“一次定义，多次调用”的优点</li><li>使用函数，可以简化代码，让代码更具有可读性</li></ul></li><li><em><strong>函数声明的提升（面试题）</strong></em><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fun</span>()</span><br><span class="line">   <span class="comment">//  函数表达式</span></span><br><span class="line">   <span class="keyword">var</span> fun = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fun</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// B A</span></span><br></pre></td></tr></table></figure><ul><li>和变量声明提升类似，函数声明也可以被替身，函数表达式不能提升</li><li>变量的提升，只提升定义，不提升值。</li><li><em><strong>函数优先提升，然后再提升变量。</strong></em></li></ul></li></ol><h2 id="函数算法题"><a href="#函数算法题" class="headerlink" title="函数算法题"></a>函数算法题</h2><ol><li>函数算法题1<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【阿姆斯特朗数】 数字是 n 位数 , 该数字的每一位的 n 次方之和等于该数字本身 </span></span><br><span class="line"><span class="comment"> *  阿姆斯特朗数是指上述条件成立的任意位数的数字 水仙花数是指上述条件成立的 3 位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result *= i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = i.<span class="title function_">toString</span>();</span><br><span class="line">        <span class="keyword">var</span> a = <span class="title class_">Number</span>(str[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">var</span> b = <span class="title class_">Number</span>(str[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">var</span> c = <span class="title class_">Number</span>(str[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">factorial</span>(a) + <span class="title function_">factorial</span>(b) + <span class="title function_">factorial</span>(c) == i) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>函数算法题2<ul><li>函数是JS的一等公民，它可以当做参数传入另一个函数</li><li>sort()函数 这个函数中的a，b分别表示数组中靠前和靠后的项，如果需要将它们交换位置，则返回任意整数，否则返回负数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">33</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">11</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// if (a &gt; b) &#123;</span></span><br><span class="line">    <span class="comment">//     return 1</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     return -1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> b-a</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arr&quot;</span>, arr)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ol><li>什么是递归<ul><li>函数的内部语句可以调用这个函数自身，从而发起对函数的一次迭代，在新的迭代中，又会执行调用函数自身的语句，从而又产生一次迭代，当函数执行到某一次时，不在进行新的迭代，函数被一层一层返回，函数被递归。</li><li>递归是一种较为高级的编程技巧，它把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</li><li>递归的要素<ul><li><strong>边界条件：确定递归到何时终止，也称为递归出口</strong></li><li><strong>递归模式：大问题是如何分解为小问题的，也称为 递归体</strong></li></ul></li></ul></li><li>递归常见算法题<ul><li>斐波那契数列<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>阶乘<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">n</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;n：&quot;</span>,n)</span><br><span class="line">         <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> n * <span class="title function_">test</span>(n - <span class="number">1</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">test</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li>实现深克隆<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">45</span>, [<span class="number">12</span>, <span class="number">44</span>]];</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> result = [];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">               result.<span class="title function_">push</span>(<span class="title function_">deepClone</span>(arr[i]))</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> arr2 = <span class="title function_">deepClone</span>(arr1);</span><br></pre></td></tr></table></figure></li></ol><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><ol><li>全局变量和局部变量<ul><li>JavaScript 是 函数作用域编程语言：变量只在其定义时所在的function内部有意义。</li><li>如果变量不定义在函数的内部，此时这个变量就是全局变量</li><li>遮蔽效应<ul><li>如果函数中也定义了和全局同名的变量，则函数内的变量会将全局的变量 “遮蔽”</li></ul></li><li>形参也是局部变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a</span>) &#123;</span><br><span class="line"> a++</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">7</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure></li><li>函数的嵌套<ul><li>一个函数内部也可以定义一个函数。和局部变量类似，定义在一个函数内部的函数时局部函数</li></ul></li><li>不加 var 将定义全局变量</li></ul></li><li>作用域链<ul><li>就是这个变量会被一层一层的（从内层到外层），去寻找它的作用域</li></ul></li><li>闭包<ul><li>什么是闭包<ul><li>Javascript 中函数会产生闭包（closure）。闭包是函数本身和该函数声明时所处的环境状态的组合。</li><li>函数能够“记忆住”其定义时所处的环境，即使函数不在其定义的环境中被调用，也能访问定义时所处环境的变量。</li></ul></li><li>观察闭包现象<ul><li>在JavaScript中，每次创建函数时都会创建闭包。但是，闭包特性往往需要将函数“换一个地方”执行，才能观察出来</li></ul></li><li>闭包非常实用<ul><li>因为它允许我们将数组与操作改数组的函数关联起来，这与“面向对象编程”有少许相似之处</li></ul></li><li>闭包的功能<ul><li>记忆性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCheckTemp</span>(<span class="params">standardTemp</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">checkTemp</span>(<span class="params">n</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (n &lt;= standardTemp) &#123;</span><br><span class="line">               <span class="title function_">alert</span>(<span class="string">&#x27;你的体温正常&#x27;</span>)</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="title function_">alert</span>(<span class="string">&#x27;你的体温偏高&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> area1 = <span class="title function_">createCheckTemp</span>(<span class="number">37.1</span>)</span><br><span class="line">   <span class="keyword">var</span> area2 = <span class="title function_">createCheckTemp</span>(<span class="number">38.1</span>)</span><br><span class="line">   <span class="title function_">area1</span>(<span class="number">38</span>)</span><br><span class="line">   <span class="title function_">area2</span>(<span class="number">38</span>)</span><br></pre></td></tr></table></figure><ul><li>当闭包产生时，函数所处环境的状态会始终保持在内存中，不会在外层函数调用后被自动清除。这就是闭包的记忆性</li></ul></li><li>模拟私有变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">getA</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> a</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> a++</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">pow</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> a *= <span class="number">2</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> obj = <span class="title function_">fun</span>()</span><br><span class="line"> obj.<span class="title function_">pow</span>()</span><br><span class="line"> obj.<span class="title function_">add</span>()</span><br><span class="line"> <span class="title function_">alert</span>(obj.<span class="title function_">getA</span>())</span><br></pre></td></tr></table></figure></li><li>使用闭包的注意点<ul><li>不能滥用闭包，否则会造成网页的性能问题，严重时可能导致内存泄漏。所谓内存泄漏是指程序中以动态分贝的内存由于某种原因未释放或无法释放</li></ul></li><li><strong>闭包面试题</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           count = count + <span class="number">1</span>;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> fun1 = <span class="title function_">addCount</span>()</span><br><span class="line">   <span class="keyword">var</span> fun2 = <span class="title function_">addCount</span>()</span><br><span class="line">   <span class="title function_">fun1</span>()</span><br><span class="line">   <span class="title function_">fun2</span>()</span><br><span class="line">   <span class="title function_">fun2</span>()</span><br><span class="line">   <span class="title function_">fun1</span>()</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><ol><li>立即执行函数 IIFE</li><li>立即调用函数，一旦被定义，就立即被调用</li><li>形成IIFE的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行函数 </span></span><br><span class="line">+<span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="string">&#x27;立即调用1&#x27;</span>); &#125;() </span><br><span class="line">-<span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="string">&#x27;立即调用2&#x27;</span>); &#125;()</span><br><span class="line">~<span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="string">&#x27;立即调用3&#x27;</span>); &#125;() </span><br><span class="line">!<span class="keyword">function</span> <span class="title function_">fun4</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="string">&#x27;立即调用4&#x27;</span>); &#125;()</span><br></pre></td></tr></table></figure><ul><li>函数必须转为“函数表达式”才能被调用</li></ul></li><li>IIFE的作用<ul><li>为变量赋值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">var</span> sex = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> title = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;小朋友&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sex == <span class="string">&#x27;男&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;先生&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;女士&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">    <span class="title function_">alert</span>(title)</span><br></pre></td></tr></table></figure></li><li>将全局变量变为局部变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">             arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                 <span class="title function_">alert</span>(i)</span><br><span class="line">             &#125;)</span><br><span class="line">         &#125;)(i)</span><br><span class="line">     &#125;</span><br><span class="line">     arr[<span class="number">1</span>]()</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数的基本使用&quot;&gt;&lt;a href=&quot;#函数的基本使用&quot; class=&quot;headerlink&quot; title=&quot;函数的基本使用&quot;&gt;&lt;/a&gt;函数的基本使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数的参数和返回值&lt;ul&gt;
&lt;li&gt;参数可多可少，用逗号分开&lt;/li&gt;
&lt;li&gt;函数体内</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="https://zhihuzeye.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://zhihuzeye.github.io/2024/06/13/DOM/"/>
    <id>https://zhihuzeye.github.io/2024/06/13/DOM/</id>
    <published>2024-06-13T15:24:33.000Z</published>
    <updated>2024-09-26T12:25:30.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM-基本概念"><a href="#DOM-基本概念" class="headerlink" title="DOM 基本概念"></a>DOM 基本概念</h2><ol><li>DOM 是操控 HTML和CSS的桥梁</li><li>DOM (Doucument Object Model) 文档对象类型，是Javascript操作HTML文档的接口，使文档操作变得非常优雅简便</li><li>DOM最大的特点是将文档表示为节点树</li></ol><h2 id="节点访问和位置关系"><a href="#节点访问和位置关系" class="headerlink" title="节点访问和位置关系"></a>节点访问和位置关系</h2><ol><li>访问元素节点<ul><li>访问元素节点的常用方法<ul><li><code>document.getElementById()</code><ul><li>通过id得到元素<ul><li>如果页面上有相同id的元素，则只能得到一个</li><li>不管元素藏得多深，都能把它找到</li><li>延迟运行<ul><li>通常JS 一定要写到HTML的节点后面，否则JS无法找到相应的HTML节点</li><li>可以使用 window.onload &#x3D; function(){} 事件 ,使页面加载完后再执行指定代码</li></ul></li></ul></li></ul></li><li><code>document.getElementsByTagName()</code><ul><li>通过标签名称得到元素数组</li></ul></li><li><code>document.getElementsByClassName()</code><ul><li>通过类名得到元素数组</li></ul></li><li><code>document.querySelector()</code><ul><li>通过选择器得到元素</li></ul></li><li><code>document.querySelectorAll()</code><ul><li>通过选择器得到元素数组</li></ul></li></ul></li></ul></li><li>节点的关系<ul><li>相对于父节点<ul><li>可以使用 farstChild  得到第一个子节点</li><li>可以使用 lastChild 得到最后一个子节点</li></ul></li><li>相对于子节点<ul><li>父节点可以通过使用 childNodes 得到所有的子节点信息</li><li>子节点可以通过 parentNode 来访问父节点</li><li>对于后面一个 兄弟节点 可以使用 nextSibling 获取</li><li>对于前面一个兄弟节点 可以使用 perviousSibling 获取前面一个</li></ul></li><li><strong>注意：文本节点也属于节点</strong><ul><li>文本节点也属于节点，使用节点关系时，一定要注意</li></ul></li><li>只考虑元素节点<ul><li>children</li><li>firstElementChild</li><li>lastElementChild</li><li>perviousElementSibling</li><li>nextElementSiling</li></ul></li></ul></li></ol><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><ol><li>insertBefore<ul><li>父节点.insertBefore(孤儿节点,标杆节点);</li></ul></li><li>appendChild<ul><li>父节点.appendChild(内容)</li><li>在尾部追加</li></ul></li><li>改变元素节点的CSS样式<ul><li><code>oBox.style.fontSize  = &#39;32px&#39;</code></li></ul></li><li>改变元素的HTML的属性<ul><li>W3C 属性 直接，元素.属性 &#x3D; 属性值</li><li>非标准 W3C 属性 <ul><li>元素.setAttribute(key,value)</li><li>元素.getAttribute(key)</li></ul></li></ul></li></ol><h2 id="nodeType常用属性值"><a href="#nodeType常用属性值" class="headerlink" title="nodeType常用属性值"></a>nodeType常用属性值</h2><ul><li>1  <code>元素节点，例如&lt;p&gt; 和 &lt;div&gt;</code></li><li>3  <code>文字节点</code></li><li>8  <code>注释节点</code></li><li>9  <code>document节点</code></li><li>10  <code>DTD节点</code></li></ul><h2 id="节点的创建、移除和克隆"><a href="#节点的创建、移除和克隆" class="headerlink" title="节点的创建、移除和克隆"></a>节点的创建、移除和克隆</h2><ol><li>createElement<ul><li>创建一个指定tagname的HTML元素</li></ul></li><li>获取body节点<ul><li>document.body</li></ul></li><li>获取html节点<ul><li>document.documentElement</li></ul></li><li>移动节点<ul><li>新父节点.appendChild(已经有父亲的节点)</li><li>新父节点.insterBefore(已经有父亲的节点,标杆子节点)</li></ul></li><li>删除节点<ul><li>父节点.removeChild(要删除的子节点)</li><li><strong>节点不能主动删除自己，必须由父节点删除它</strong></li></ul></li><li>克隆节点<ul><li>cloneNode() 方法可以克隆节点，克隆出的节点是“孤儿节点”</li><li>var 孤儿节点 &#x3D; 老节点.cloneNode(true|false);</li><li>cloneNode 参数是一个布尔值，表示是否采用深度克隆；如果为true该节点的所有后代节点也都会被克隆，如果为false，则只克隆该节点本身</li></ul></li><li>访问元素节点<ul><li>所谓 ”访问“元素节点，就是指”得到“、”获取“页面上的元素节点。</li><li>访问元素节点 主要依赖于 document</li></ul></li></ol><h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><ol><li>事件监听<ul><li>什么是“事件监听”<ul><li>DOM允许我们书写Javascript代码以让HTML元素对事件做出反应</li><li>什么是”事件”：用户与网页的交互动作<ul><li>点用户点击元素的时候</li><li>点鼠标移动到元素的时候</li><li>当网页加载完成的时候…</li></ul></li><li>“监听”,顾名思义就是让计算机随时能够发现这个事件发生了，从而执行程序员预先编写的一些程序</li><li>设置事件监听的方法主要有 onxxx 和 addEventListener()</li></ul></li><li>常见鼠标事件监听<ul><li><code>onclick 当鼠标点击某个对象</code></li><li><code>ondblclick 当鼠标双击某个对象</code></li><li><code>onmousedown 当某个鼠标按键在某个对象上被按下</code></li><li><code>onmouseup 当某个鼠标按键在某个对象上被松开</code></li><li><code>onmousemove 当某个鼠标按键在某个对象上被移动</code></li><li><code>onmouseenter 当鼠标进入某个对象</code></li><li><code>onmouseleave 当鼠标离开某个对象</code></li></ul></li><li>常见的键盘事件监听<ul><li><code>onkeyperss 当某个键盘的键被按下（系统按钮如箭头键和功能键无法得到识别）</code></li><li><code>onkeydown 当某个键盘的键被按下（系统按钮可以识别，并且会优先onkeypress发生）</code></li><li><code>onkeyup 当某个键盘的键被松开</code></li></ul></li><li>常见的表单事件监听<ul><li><code>onchange 当用户改变域的内容</code></li><li><code>onfocus 当某个元素获得焦点（比如tab或鼠标点击）</code></li><li><code>onblur 当元素失去焦点</code></li><li><code>onsubmit 当表单被提交</code></li><li><code>onreset 当表单被重置 </code></li><li><code>oninput 当用户输入</code></li></ul></li><li>常见的页面事件监听<ul><li><code>onload 当页面或图像被完成加载</code></li><li><code>onunload  当用户退出页面</code></li></ul></li></ul></li><li>事件传播<ul><li>事件的传播是：先从外到内，然后再从内到外<ul><li>从外到内、捕获阶段（capturing phase）</li><li>从内到外、冒泡阶段（Bubbling phase）</li><li>onxxx 这样的写法只能监听冒泡阶段</li></ul></li><li>addEventListener() 方法<ul><li>DOM 0级：只能监听冒泡阶段<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box2.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是box2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>DOM 2级事件监听<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li><em><strong>true 监听捕获的阶段</strong></em></li><li><em><strong>false 监听冒泡阶段【默认】</strong></em></li></ul></li><li><strong>注意事项：最内部的元素不再区分捕获和冒泡阶段，会先执行写在前面的监听，然后执行后写的监听</strong></li><li><strong>注意事项：如果给元素设置相同的两个或多个同名事件，则DOM0级写法后面写的会覆盖先写的；而DOM2级会按照顺序执行</strong></li></ul></li></ul></li><li>事件对象<ul><li>什么是事件对象<ul><li>事件处理函数提供一个形式参数，它是一个对象，封装了本次事件的细节</li></ul></li><li>e.charCode 和 e.keyCode 属性<ul><li>e.charCode 属性通常用于 onkeypress 事件中，表示用户输入的字符的 “字符码”<ul><li><code>数字0 ~ 数字9  48 ~ 57</code></li><li><code>大写字母A ~ Z  65 ~ 90</code></li><li><code>小写字母 a ~ z  97 ~ 122</code></li></ul></li><li>e.keyCode 属性通常用于 onkeydown 事件和onkeyup中，表示用户按下按键的 “键码”<ul><li><code>数字0 ~ 数字9  48 ~ 57</code></li><li><code>字母部分大小写 a ~ z  65 ~ 90 （不区分大小写）</code></li><li><code>四个方向键（左、上、右、下）  37、38、39、40</code></li><li><code>回车键  13</code></li><li><code>空格键  32</code></li></ul></li></ul></li><li><em><strong>e.preventDefault() 方法</strong></em><ul><li>阻止事件产生的“默认动作”</li></ul></li><li><em><strong>e.stopPropagation() 方法</strong></em><ul><li>阻止事件继续传播</li><li>在一些场合，非常有必要切断事件继续传播，否则会造成页面特效显示出bug</li></ul></li><li>鼠标滚轮事件<ul><li>鼠标滚轮事件是 onmousewheel ，它的事件对象e提供deltaY 属性 表示鼠标滚动方向，向下滚动时返回正值，向上滚动时，返回负值。</li></ul></li></ul></li><li><strong>事件委托</strong><ul><li>批量添加事件监听的性能问题<ul><li>每一个事件监听注册都会消耗一定的系统内存，而批量添加事件会导致监听数量太多，内存消耗会非常大</li></ul></li><li>定义<ul><li>利用事件冒泡机制，将后台元素事件委托给祖先元素</li></ul></li><li>e.target 和 e.currentTarget 属性<ul><li>target<ul><li><em><strong>触发此事件的最早元素，即“事件源元素”</strong></em></li></ul></li><li>currentTarget<ul><li>事件处理程序附加到的元素</li></ul></li></ul></li><li>使用场景<ul><li>当有大量类似元素需要批量添加事件监听时，使用事件委托可以减少内存开销</li><li>当有动态元素节点上树时，使用事件委托可以让新上树的元素具有事件监听</li></ul></li><li>使用时注意事项<ul><li>onmouseenter 和 onmouseover 都表示“鼠标进入”，它们有什么区别呢？<ul><li>onmouseenter 不冒泡</li><li>onmouseover 冒泡</li></ul></li><li><em><strong>不能委托不冒泡的事件给祖先元素</strong></em></li><li>最内层的元素不能再有额外的内层元素了，比如<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DOM-基本概念&quot;&gt;&lt;a href=&quot;#DOM-基本概念&quot; class=&quot;headerlink&quot; title=&quot;DOM 基本概念&quot;&gt;&lt;/a&gt;DOM 基本概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DOM 是操控 HTML和CSS的桥梁&lt;/li&gt;
&lt;li&gt;DOM (Doucum</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="https://zhihuzeye.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BOM基础</title>
    <link href="https://zhihuzeye.github.io/2024/06/12/BOM%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhihuzeye.github.io/2024/06/12/BOM%E5%9F%BA%E7%A1%80/</id>
    <published>2024-06-12T14:37:14.000Z</published>
    <updated>2024-09-26T12:25:30.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BOM是什么"><a href="#BOM是什么" class="headerlink" title="BOM是什么"></a>BOM是什么</h2><ol><li>一些与浏览器改变尺寸，滚动条滚动的特效，都要借助BOM技术</li><li>BOM(Browser Object Model, 浏览器对象模型) 是JS与浏览器窗口交互的接口</li></ol><h2 id="BOM常用对象"><a href="#BOM常用对象" class="headerlink" title="BOM常用对象"></a>BOM常用对象</h2><ol><li>Window 对象<ul><li>window 对象是当前JS脚本运行所处的窗口，而这个窗口中包含DOM结构，window.document属性就是document对象</li><li>在有标签页功能的浏览器中，每个标签都拥有自己的window 对象；也就是说，同一个窗口的标签页之间不会共享一个window对象</li><li>全局变量是window变量的属性<ul><li><code>var a = 1;window.a == a   // true</code></li></ul></li><li>内置函数普遍是window的方法<ul><li><code>如setInterval、alert </code></li><li><code>window.alert ==alert // true</code></li><li><code>window.hasOwnProperty(&#39;alert&#39;) // true</code></li></ul></li></ul></li><li>Navigator 对象<ul><li>window.navgator 属性可以检索navigator对象，它内部含有用户此次活动的浏览器的相关属性和标识<ul><li>appName 浏览器官方名称</li><li>appVersion 浏览器版本</li><li>userAgent 浏览器用户代理（含有内核信息和封装壳信息）</li><li>platform 用户操作系统</li></ul></li></ul></li><li>History 对象<ul><li>window.history 对象提供了操作浏览器会话历史的接口</li><li>常用的操作就是模拟浏览器的回退按钮</li><li><code>history.back() history.go(-1)</code></li></ul></li><li>History 对象<ul><li>window.location 标识当前所在网址，可以通过给这个属性赋值命令浏览器进行页面跳转</li><li>重新加载当前页面</li><li>可以调用location的reload方法以重新加载当前页面，参数true标识强制从服务器加载</li><li>GET请求查询参数<ul><li>window.location.search 属性即为当前浏览器的GET请求查询参数</li></ul></li></ul></li><li>窗口尺寸相关属性<ul><li>innerHeight<ul><li>浏览器窗口的内容区域的高度，包含水平滚动条（如果有的话）</li></ul></li><li>innerWidth<ul><li>浏览器窗口的内容区域宽度，包含垂直滚动条（如果有的话）</li></ul></li><li>outerHeight<ul><li>浏览器窗口的外部高度</li></ul></li><li>outerWidth<ul><li>浏览器窗口的外部宽度</li></ul></li><li>获得不包含滚动条的窗口宽度，要用 document.documentElement.clientWidth</li><li>resize 事件<ul><li>在窗口大小改变以后，就会触发resize事件，可以使用window.onresize或者window.addEventListener(‘resize’) 来绑定事件处理函数</li></ul></li><li>已卷动高度<ul><li>window.scrollY 属性表示在垂直方向已滚动的像素值</li></ul></li><li>已动高度<ul><li>document.documentElement.scrollTop 属性也表示窗口卷动高度</li><li>document.documentElement.scrollTop 不是只读的，window.scrollY 属性是只读的</li></ul></li><li>scroll事件<ul><li>在窗口被卷动之后，就会触发scroll事件，可以使用 window.onscroll 或者 window.addEventListener(‘scroll’) 来绑定事件处理函数</li></ul></li><li>DOM元素都有offsetTop属性，表示此元素定位到祖先元素的垂直距离<ul><li>定位祖先元素：在祖先中，离自己最近的且拥有定位属性的元素</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BOM是什么&quot;&gt;&lt;a href=&quot;#BOM是什么&quot; class=&quot;headerlink&quot; title=&quot;BOM是什么&quot;&gt;&lt;/a&gt;BOM是什么&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;一些与浏览器改变尺寸，滚动条滚动的特效，都要借助BOM技术&lt;/li&gt;
&lt;li&gt;BOM(Brows</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="https://zhihuzeye.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>文本与字体属性</title>
    <link href="https://zhihuzeye.github.io/2024/06/12/%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7/"/>
    <id>https://zhihuzeye.github.io/2024/06/12/%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7/</id>
    <published>2024-06-12T14:26:19.000Z</published>
    <updated>2024-09-26T12:25:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用文本样式属性"><a href="#常用文本样式属性" class="headerlink" title="常用文本样式属性"></a>常用文本样式属性</h2><ol><li>color<ul><li>设置文本内容的前景色<ul><li>RGBA ，最后一个表示透明度，0表示纯透明，1表示纯实心</li></ul></li><li>16进制，RGB，RGBA</li><li><strong>如果颜色值是#aabbcc的形式，可以简写为#abc</strong><ul><li>#ff0000 -&gt; #f00</li></ul></li></ul></li><li>font-size<ul><li>设置字号，单位通常px</li></ul></li><li>font-weight<ul><li>normal  正常粗细，与400等值</li><li>bold  加粗，与700等值</li><li>lighter  更细，大多数中文字体不支持</li><li>bolder  更粗，大多数中文字体不支持</li></ul></li><li>font-style<ul><li>normal  取消倾斜，比如把天生倾斜的i、em等标签设置为不倾斜</li><li>italic  设置为倾斜字体（常用）</li><li>oblique  设置为倾斜字体（用常规字体模拟，不常用）</li></ul></li><li>text-decoration<ul><li>none  没有修饰线</li><li>underline  下划线</li><li>line-through  删除线</li></ul></li></ol><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><ol><li>color</li><li>font-开头的</li><li>list-开头的</li><li>text-开头的</li><li>line-开头的</li><li><em><strong>因为文字相关属性有继承性，所以通常会设置body标签的字号、颜色、行高等，这样就能当做整个网页的默认样式了</strong></em></li><li><em><strong>在继承的情况下，选择器权重计算失效，而是“就近原则”，继承的不如元素选中的权重大</strong></em></li></ol><h2 id="字体属性详解"><a href="#字体属性详解" class="headerlink" title="字体属性详解"></a>字体属性详解</h2><ol><li>font-family<ul><li>字体可以是列表形式，一般英语字体放前面，后面的字体是前面字体的“后备”字体</li><li>font-family: serif, “Times New Roman”, “微软雅黑”;</li><li>字体名称中有空格，必须用引号包裹</li><li>中文字体可以称呼它们的英语名字<ul><li>“Microsoft Yahei”  等同于 “微软雅黑”</li><li>“SimSun” 等价于 “宋体”</li></ul></li><li><strong>字体通常必须是用户计算机中已经安装好的字体</strong></li><li>定义新字体，需要我们有新字体  @font-face</li></ul></li></ol><h2 id="段落和行相关属性"><a href="#段落和行相关属性" class="headerlink" title="段落和行相关属性"></a>段落和行相关属性</h2><ol><li>text-indent 属性<ul><li>定义文本内容首行缩进量</li></ul></li><li>line-height<ul><li>定义行高</li><li>line-height:30px</li><li>line-height:1.5  字号的倍数</li><li>line-height:150%   字号的倍数</li></ul></li><li>单行文本垂直居中<ul><li>行高&#x3D;盒子高度，即可实现单行文本的垂直居中</li></ul></li><li>text-align:center<ul><li>文字水平居中</li></ul></li><li>font 合写属性<ul><li>font: italic bold 20px&#x2F;1.5 “阿里妈妈刀隶体 Regular”;</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用文本样式属性&quot;&gt;&lt;a href=&quot;#常用文本样式属性&quot; class=&quot;headerlink&quot; title=&quot;常用文本样式属性&quot;&gt;&lt;/a&gt;常用文本样式属性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;color&lt;ul&gt;
&lt;li&gt;设置文本内容的前景色&lt;ul&gt;
&lt;li&gt;RGBA ，最</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://zhihuzeye.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>盒模型</title>
    <link href="https://zhihuzeye.github.io/2024/06/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zhihuzeye.github.io/2024/06/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-06-12T14:11:47.000Z</published>
    <updated>2024-09-26T12:25:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识盒模型"><a href="#认识盒模型" class="headerlink" title="认识盒模型"></a>认识盒模型</h2><ol><li>行内元素</li><li>块级元素</li><li>所有HTML标签都可以看成矩形盒子，由width、height、padding、border构成，称为“盒模型”</li></ol><h2 id="width和height属性详解"><a href="#width和height属性详解" class="headerlink" title="width和height属性详解"></a>width和height属性详解</h2><ol><li>width<ul><li>盒子内容的宽度</li><li>width属性通常是px，移动端开发会涉及百分数，rem等单位</li><li>当块级元素（div、h系列、li等）没有设置width属性是，它将自动撑满，但这并不意味着width可以继承</li></ul></li><li>height<ul><li>表示内容的高度</li><li>width属性通常是px，移动端开发会涉及百分数，rem等单位</li><li>盒子的height属性如果不设置，它将被内容被自动撑开，如果没有内容，则height默认是0</li><li>高度省略掉，内容能被自动撑开</li></ul></li></ol><h2 id="padding属性详解"><a href="#padding属性详解" class="headerlink" title="padding属性详解"></a>padding属性详解</h2><ol><li>padding 是盒子的内边距，即盒子边框内壁到文字的距离</li><li>padding 是四个方向的<ul><li>padding-top</li><li>padding-left</li><li>padding-right</li><li>padding-bottom</li></ul></li><li>padding 四数值写法<ul><li>padding:10px 20px 10px 20px 上右下左</li></ul></li><li>padding 三数值写法 <ul><li><em><strong>padding:10px 20px 30px  上 左右 下</strong></em></li></ul></li><li>padding 二数值写法<ul><li>padding:10px 20px 上下，左右</li></ul></li><li>padding 一数值写法<ul><li>padding:10px  四个方向都是10px</li></ul></li></ol><h2 id="margin属性详解"><a href="#margin属性详解" class="headerlink" title="margin属性详解"></a>margin属性详解</h2><ol><li>margin是盒子的外边距，盒子和其它盒子之间的距离</li><li>margin 是四个方向的<ul><li>margin-top</li><li>margin-left</li><li>margin-right</li><li>margin-bottom</li></ul></li><li>margin 四个方向<ul><li>margin:10px 20px 10px 20px 上右下左</li></ul></li><li>margin 三数值写法 <ul><li><em><strong>margin:10px 20px 30px  上 左右 下</strong></em></li></ul></li><li>margin 二数值写法<ul><li>margin:10px 20px 上下，左右</li></ul></li><li>margin 一数值写法<ul><li>margin:10px  四个方向都是10px</li></ul></li><li>margin 的塌陷<ul><li>垂直方向的margin有塌陷现象：小的margin 会塌陷到大的margin 中，从而margin不叠加，只以大的值为准<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.box5</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: aqua;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">24px</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> <span class="selector-class">.box6</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">28</span>, <span class="number">206</span>, <span class="number">108</span>);</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">32px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">以<span class="attribute">margin-top</span> <span class="number">32px</span> 为准</span><br></pre></td></tr></table></figure></li><li>左右方向不会发生塌陷现象</li></ul></li><li>一些元素有默认的margin<ul><li>比如（body、ul、p) 等，在开始制作网页的时候，要将它们清除<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> *&#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">body</span>,</span><br><span class="line">    <span class="selector-tag">ul</span>,</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">* 通配符有效率问题</span><br></pre></td></tr></table></figure></li></ul></li><li>盒子的水平居中<ul><li>将盒子左右两边的margin都设置为auto，盒水平居中 </li><li>margin:0 auto</li><li>文本居中 text-align:center 和盒子水平居中是两个概念</li></ul></li></ol><h2 id="盒模型计算"><a href="#盒模型计算" class="headerlink" title="盒模型计算"></a>盒模型计算</h2><ol><li>盒子的总宽度 &#x3D; width + 左右border + 左右padding</li><li>盒子的总高度 &#x3D; height + 上下border + 上下padding</li></ol><h2 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h2><ol><li>将盒子添加 box-sizing:border-box 之后，padding、border 变为内缩，不再外扩</li></ol><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><ol><li>行内元素<ul><li>能并排显示</li><li>不能设置宽高</li><li>width自动收缩</li><li>a、span、em、b、u、i 等</li></ul></li><li>块级元素<ul><li>不能并排显示</li><li>能设置宽高</li><li>width自动撑满</li><li>div、section、header、h系列、li、ul等</li></ul></li><li>行内块元素<ul><li>img、input等</li><li>既能并排显示、又能设置宽高</li></ul></li><li>行内元素和块级元素的互相转换<ul><li>display:block<ul><li>转换为块级元素</li></ul></li><li>display:inline <ul><li>转为行内元素</li></ul></li><li>disaplay:inline-block <ul><li>即将元素转为行内块</li></ul></li><li>display:none<ul><li>可以将元素隐藏，元素将彻底放弃位置，如同没有写标签一样</li></ul></li><li>visibility:hidden<ul><li>也可以将元素隐藏，但是元素不放弃自己的位置</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识盒模型&quot;&gt;&lt;a href=&quot;#认识盒模型&quot; class=&quot;headerlink&quot; title=&quot;认识盒模型&quot;&gt;&lt;/a&gt;认识盒模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;行内元素&lt;/li&gt;
&lt;li&gt;块级元素&lt;/li&gt;
&lt;li&gt;所有HTML标签都可以看成矩形盒子，由width</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://zhihuzeye.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>过渡与动画</title>
    <link href="https://zhihuzeye.github.io/2024/06/12/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://zhihuzeye.github.io/2024/06/12/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2024-06-12T13:52:21.000Z</published>
    <updated>2024-09-26T12:25:30.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过渡（最低支持-IE10）"><a href="#过渡（最低支持-IE10）" class="headerlink" title="过渡（最低支持 IE10）"></a>过渡（最低支持 IE10）</h2><ol><li>过渡的基本使用<ul><li>transition 过渡属性是CSS3浓墨重彩的特性，过渡可以为一个元素在不同的样式之间变化自动添加“补间动画”</li><li>优点：动画更细腻，内存开销小</li><li>transition: width 1s linear 0s;<ul><li>如果所有属性要参与过渡，可以写 all</li></ul></li><li><em><strong>参数说明：什么属性需要过渡，动画时长，变化速度曲线，延迟时间</strong></em><br>  过渡的四个小属性<ul><li>transition-duration 动画时间</li><li>transition-property 哪些属性要过渡</li><li>transition-timing-function 动画变化曲线（缓动效果）<ul><li>ease</li><li>linear</li><li>ease-in</li><li>ease-out</li><li>ease-in-out</li><li>贝塞尔曲线<ul><li>可以通过 <a href="https://cubic-bezier.com/">https://cubic-bezier.com/</a> 这个网址自定义动画缓动参数</li></ul></li></ul></li><li>transition-delay 延迟时间</li></ul></li><li>哪些属性可以参与过渡？<ul><li>所有数值属性都可以参与过渡，比如<ul><li>width</li><li>height</li><li>left</li><li>top</li><li>border-radius</li></ul></li><li>背景颜色和文字颜色都可以被过渡</li><li>所有变形（包括2D和3D）都能被过渡</li></ul></li></ul></li><li>过渡的缓动效果（参考 transition-timing-function 属性）</li></ol><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ol><li>动画的定义和调用<ul><li><p>可以使用 @keyframes 来定义动画，keyframes 表示“关键帧”，在项目上线前，要补上@-webkit-这样的私有前缀</p></li><li><p>定义动画后，就可以用 animation 属性调用动画</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>动画的定义<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="keyword">@keyframes</span> r&#123;</span></span><br><span class="line"><span class="language-css">          <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="language-css">              <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">          &#125;</span></span><br><span class="line"><span class="language-css">          <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="language-css">              <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">          &#125;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">animation</span>: r <span class="number">1s</span> linear <span class="number">0s</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>animation: r 1s ease 3s 3; </code></p><ul><li>动画的参数：动画的名称，执行的时间，动画效果，延迟时间，执行次数</li><li>如果想永远设置执行就是 infinite 属性</li><li>如果想让动画的第2、4、6…..（偶数次）自动逆向执行，那么要加上 alternate 参数即可</li><li>如果想让动画停止在最后结束状态，那么要加上 forwards</li></ul></li><li><p>多关键帧动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> changeColor &#123;</span><br><span class="line">     <span class="number">0%</span> &#123;</span><br><span class="line">         <span class="attribute">background-color</span>: red;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="number">50%</span> &#123;</span><br><span class="line">         <span class="attribute">background-color</span>: yellow;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="number">100%</span> &#123;</span><br><span class="line">         <span class="attribute">background-color</span>: aqua;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过渡（最低支持-IE10）&quot;&gt;&lt;a href=&quot;#过渡（最低支持-IE10）&quot; class=&quot;headerlink&quot; title=&quot;过渡（最低支持 IE10）&quot;&gt;&lt;/a&gt;过渡（最低支持 IE10）&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;过渡的基本使用&lt;ul&gt;
&lt;li&gt;tran</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://zhihuzeye.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>多媒体与语义化标签</title>
    <link href="https://zhihuzeye.github.io/2024/06/12/%E5%A4%9A%E5%AA%92%E4%BD%93%E4%B8%8E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <id>https://zhihuzeye.github.io/2024/06/12/%E5%A4%9A%E5%AA%92%E4%BD%93%E4%B8%8E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</id>
    <published>2024-06-12T13:37:30.000Z</published>
    <updated>2024-09-26T12:25:30.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="audio标签（兼容到IE9）"><a href="#audio标签（兼容到IE9）" class="headerlink" title="audio标签（兼容到IE9）"></a>audio标签（兼容到IE9）</h2><ol><li>属性<ul><li>autoplay（某些浏览器不支持自动播放、本地自动播放是可以的）</li><li>loop （重复播放）</li></ul></li></ol><h2 id="video-标签（兼容到IE9）"><a href="#video-标签（兼容到IE9）" class="headerlink" title="video 标签（兼容到IE9）"></a>video 标签（兼容到IE9）</h2><ol><li>属性<ul><li>同 audio 标签</li><li>width 视频播放器宽度</li></ul></li></ol><h2 id="大纲标签（区块标签）"><a href="#大纲标签（区块标签）" class="headerlink" title="大纲标签（区块标签）"></a>大纲标签（区块标签）</h2><ol><li>section 文档的区域，语义比div大</li><li>article 文档的核心文章内容，会被搜索引擎主要抓取</li><li>nav 导航条</li><li>footer 页脚</li><li>aside 文档的非必要相关内容，比如广告等</li><li>main 网页核心部分</li><li>header 页头</li></ol><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><ol><li>span 文本中的区块标签</li><li>b 加粗标签</li><li>i 斜体标签</li><li>u 下划线标签</li><li>strong 加粗标签</li><li>em 斜体标签</li><li>mark 标记标签</li><li>figure-figcaption 用于表示图片和图片的标题</li></ol><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><ol><li>a 标签<ul><li>1、a 标签 anchor 锚 的首字母<br>2、hypertext reference 超文本引用<br>3、title 用于设置鼠标的悬停文本</li><li>属性<ul><li>href 超文本引用</li><li>target<ul><li>_blank 在新窗口或新标签页中打开链接。</li><li>_self 在父级框架中打开链接。</li><li>_top 在当前窗口中打开链接（默认值）。</li><li>_parent 在顶级框架中打开链接。</li></ul></li><li>title 用于设置鼠标的悬停文本</li></ul></li><li>说明<ul><li>mailto:me.test.com 邮件</li><li>tel:135555555555 拨打电话</li><li>#top 回到顶部</li></ul></li></ul></li><li>img 标签<ul><li>src</li><li>width、height</li><li>alt  alternate 替代品的缩写，它是图像的描述，不是强制性的(有利于搜索引擎优化)</li><li>title 鼠标悬停时候显示</li><li>class、style 设置样式用</li><li>loading  指定图像加载方式，可选值有”eager”（立即加载）和”lazy”（延迟加载）。</li><li>decoding  指定图像解码方式，可选值有”async”（异步解码）和”sync”（同步解码）。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;audio标签（兼容到IE9）&quot;&gt;&lt;a href=&quot;#audio标签（兼容到IE9）&quot; class=&quot;headerlink&quot; title=&quot;audio标签（兼容到IE9）&quot;&gt;&lt;/a&gt;audio标签（兼容到IE9）&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;属性&lt;ul&gt;
&lt;li&gt;a</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://zhihuzeye.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>表格标签</title>
    <link href="https://zhihuzeye.github.io/2024/06/12/%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE/"/>
    <id>https://zhihuzeye.github.io/2024/06/12/%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE/</id>
    <published>2024-06-12T13:34:38.000Z</published>
    <updated>2024-09-26T12:25:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><ol><li>tr</li><li>td<ul><li>colspan 用来设置 td 或者 th 的列跨度</li><li>rowspan 用来设置 td 或者 th 的行跨度</li></ul></li><li>thead&#x2F;th<ul><li>标题小格（td 和 th 是同一级别的）</li><li>colspan  用来设置 td 或者 th 的列跨度</li><li>rowspan  用来设置 td 或者 th 的行跨度</li></ul></li><li>tbody</li><li>tfooter</li><li>caption<ul><li>表格的标题</li></ul></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>border <ul><li>1</li><li>2</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;table&quot;&gt;&lt;a href=&quot;#table&quot; class=&quot;headerlink&quot; title=&quot;table&quot;&gt;&lt;/a&gt;table&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;tr&lt;/li&gt;
&lt;li&gt;td&lt;ul&gt;
&lt;li&gt;colspan 用来设置 td 或者 th 的列跨度&lt;/l</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://zhihuzeye.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>表单元素</title>
    <link href="https://zhihuzeye.github.io/2024/06/06/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/"/>
    <id>https://zhihuzeye.github.io/2024/06/06/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</id>
    <published>2024-06-06T05:57:01.000Z</published>
    <updated>2024-09-26T12:25:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><ol><li>type<ul><li>color 颜色选择控件</li><li>date、time 日期时间选择控件</li><li>email 电子邮件输入控件</li><li>file 文件选择控件</li><li>number 数字输入控件</li><li>range 拖拽条</li><li>search 搜索框</li><li>url 网址输入控件</li><li>button 按钮</li><li>submit 提交，在外层为 form 情况下有效</li><li>reset 重置</li><li>password 密码</li><li>radio 单选按钮需要名称设置为一样的</li><li>checkbox 多选按钮需要名称设置为一样的</li><li>hidden 对用户不可见，隐藏字段</li></ul></li><li>placeholder 提示符</li><li>value 值 是否禁用</li><li>disabled 是否必填，在外层是form表单情况下有效</li><li>required</li><li>name</li><li>id</li><li>list<ul><li>设置预选项（list&#x3D;”province-list”）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;province-list&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;浙江杭州&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;河北石家庄&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;浙江温州&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h2><ol><li>name</li><li>id</li><li>cols 一行显示多少字符</li><li>rows 一列显示多少字符</li><li>placeholder 提示符</li></ol><h2 id="select-option"><a href="#select-option" class="headerlink" title="select&#x2F;option"></a>select&#x2F;option</h2><ol><li>select</li></ol><ul><li>name</li><li>id</li><li>disable 是否禁用</li><li>multiple 选项是否支持多选</li><li>required 是否必填</li><li>autofocus 自动获取焦点</li><li>autocomplete 自动完成</li></ul><h2 id="fieldset-legend"><a href="#fieldset-legend" class="headerlink" title="fieldset&#x2F;legend"></a>fieldset&#x2F;legend</h2><ol><li>即输入区加有文字的边框。</li><li>定义域的标题，即边框上的文字。</li></ol><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><ol><li>定义一个按钮。</li></ol><h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><ol><li>定义一个控制的标签。如输入框前的文字，用以关联用户的选择。</li><li>for</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;input&quot;&gt;&lt;a href=&quot;#input&quot; class=&quot;headerlink&quot; title=&quot;input&quot;&gt;&lt;/a&gt;input&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;type&lt;ul&gt;
&lt;li&gt;color 颜色选择控件&lt;/li&gt;
&lt;li&gt;date、time 日期时间选择控</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhihuzeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://zhihuzeye.github.io/tags/HTML/"/>
    
    <category term="CSS3" scheme="https://zhihuzeye.github.io/tags/CSS3/"/>
    
  </entry>
  
</feed>
