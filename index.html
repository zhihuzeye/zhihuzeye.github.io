<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhihuzeye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="积跬步，至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="泽野之乡">
<meta property="og:url" content="https://zhihuzeye.github.io/index.html">
<meta property="og:site_name" content="泽野之乡">
<meta property="og:description" content="积跬步，至千里">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="之乎泽野">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhihuzeye.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>泽野之乡</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="泽野之乡" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">泽野之乡</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="之乎泽野"
      src="/images/face1.png">
  <p class="site-author-name" itemprop="name">之乎泽野</p>
  <div class="site-description" itemprop="description">积跬步，至千里</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhihuzeye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhihuzeye" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kydlyj@gmail.com" title="E-Mail → mailto:kydlyj@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/" class="post-title-link" itemprop="url">微信小程序关联服务号发送模板消息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-09 17:37:03 / 修改时间：17:50:08" itemprop="dateCreated datePublished" datetime="2025-07-09T17:37:03+08:00">2025-07-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微信小程序关联服务号发送模板消息全流程"><a href="#微信小程序关联服务号发送模板消息全流程" class="headerlink" title="微信小程序关联服务号发送模板消息全流程"></a>微信小程序关联服务号发送模板消息全流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于微信小程序模板消息有行业限制，且长期模板申请门槛较高，因此在某些业务场景下，使用小程序自身模板消息并不灵活。</p>
<p>针对这种情况，可以通过“微信开放平台”关联小程序与服务号的方式，由服务号代替小程序发送模板消息，从而实现消息通知。</p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>要实现小程序与服务号的消息打通，必须完成以下认证操作：</p>
<ol>
<li><strong>微信服务号认证</strong>：费用 ¥300 &#x2F; 年；</li>
<li><strong>微信小程序认证</strong>：费用 ¥300 &#x2F; 年；</li>
<li><strong>微信开放平台认证</strong>：费用 ¥300 &#x2F; 年。</li>
</ol>
<p>⚠️ 注意：三个认证缺一不可。</p>
<h2 id="微信开放平台绑定操作"><a href="#微信开放平台绑定操作" class="headerlink" title="微信开放平台绑定操作"></a>微信开放平台绑定操作</h2><ol>
<li>登录 <a target="_blank" rel="noopener" href="https://open.weixin.qq.com/">微信开放平台</a>，完成认证；</li>
<li>在“账号管理”中，绑定你的 <strong>微信小程序</strong> 和 <strong>服务号</strong>。</li>
</ol>
<p>绑定成功后，两个账号将共享同一 <strong>UnionID</strong>，可实现用户身份互通。</p>
<p><img src="/images/WX20250709-174425@2x.png" alt="开放平台绑定示意图"></p>
<h2 id="核心流程详解"><a href="#核心流程详解" class="headerlink" title="核心流程详解"></a>核心流程详解</h2><ol>
<li>用户在<strong>小程序</strong>中登录，获取 <strong>UnionID</strong>；</li>
<li>通过 UnionID 查询对应的 <strong>服务号 openid</strong>；</li>
<li>服务号根据 openid，调用消息推送接口发送模板消息。</li>
</ol>
<p>流程图如下：</p>
<p><img src="/images/sj112sadad1.png" alt="核心流程图解"></p>
<h2 id="核心接口文档参考"><a href="#核心接口文档参考" class="headerlink" title="核心接口文档参考"></a>核心接口文档参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">微信小程序 UnionID 机制说明</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/service/api/usermanage/userinfo/api_batchuserinfo.html">微信服务号 批量获取用户基本信息接口</a></li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过微信开放平台绑定小程序与服务号，并结合 UnionID 机制，可以灵活实现小程序与服务号间的消息互通。<br>这种方式适合对消息通知有较高需求的应用场景，是微信官方推荐的解决方案之一。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/07/02/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">微信消息推送的几种方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-02 10:36:47 / 修改时间：11:44:34" itemprop="dateCreated datePublished" datetime="2025-07-02T10:36:47+08:00">2025-07-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微信消息推送的几种方式"><a href="#微信消息推送的几种方式" class="headerlink" title="微信消息推送的几种方式"></a>微信消息推送的几种方式</h1><h2 id="一、推送方式及对比"><a href="#一、推送方式及对比" class="headerlink" title="一、推送方式及对比"></a>一、推送方式及对比</h2><p>微信平台支持多种消息推送方式，主要包括以下三种：</p>
<table>
<thead>
<tr>
<th>推送方式</th>
<th>使用平台</th>
<th>消息类型</th>
<th>用户接受程度</th>
</tr>
</thead>
<tbody><tr>
<td>小程序推送</td>
<td>微信小程序</td>
<td>模板消息 &#x2F; 服务通知</td>
<td>★★★★★（强提醒）</td>
</tr>
<tr>
<td>服务号推送</td>
<td>微信服务号</td>
<td>模板消息</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>公众号推送</td>
<td>微信订阅号</td>
<td>图文消息 &#x2F; 通知</td>
<td>★★★☆☆</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>通知强提醒等级排序：服务通知 &gt; 服务号 &gt; 公众号</strong></p>
</blockquote>
<hr>
<h2 id="二、推送效果截图"><a href="#二、推送效果截图" class="headerlink" title="二、推送效果截图"></a>二、推送效果截图</h2><h3 id="1-服务通知截图"><a href="#1-服务通知截图" class="headerlink" title="1. 服务通知截图"></a>1. 服务通知截图</h3><p><img src="/images/WechatIMG406.jpg" alt="服务通知示例"></p>
<hr>
<h3 id="2-服务号通知截图"><a href="#2-服务号通知截图" class="headerlink" title="2. 服务号通知截图"></a>2. 服务号通知截图</h3><p><img src="/images/WechatIMG407.jpg" alt="服务号示例"></p>
<hr>
<h3 id="3-公众号通知截图"><a href="#3-公众号通知截图" class="headerlink" title="3. 公众号通知截图"></a>3. 公众号通知截图</h3><p><img src="/images/WechatIMG408.jpg" alt="公众号示例"></p>
<hr>
<h2 id="三、小程序消息推送说明"><a href="#三、小程序消息推送说明" class="headerlink" title="三、小程序消息推送说明"></a>三、小程序消息推送说明</h2><p>小程序支持不同类型的消息模板推送，其模板分类与使用要求如下：</p>
<h3 id="小程序模板分类说明"><a href="#小程序模板分类说明" class="headerlink" title="小程序模板分类说明"></a>小程序模板分类说明</h3><table>
<thead>
<tr>
<th>类型</th>
<th>类目要求</th>
<th>使用限制</th>
</tr>
</thead>
<tbody><tr>
<td>新版一次性订阅消息</td>
<td>仅支持电商等特定类目</td>
<td>用户订阅后可发送 1 条消息，<strong>无时间限制</strong></td>
</tr>
<tr>
<td>一次性订阅消息</td>
<td>一般类目均可使用</td>
<td>同上</td>
</tr>
<tr>
<td>长期订阅消息</td>
<td>仅限政务民生、医疗、教育等公共服务类目</td>
<td>当前使用方式未公开</td>
</tr>
<tr>
<td>设备订阅消息</td>
<td>公共服务类目，需接入硬件设备支持</td>
<td>每日对单一用户可发送 1 条消息</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <strong>说明</strong>：新版模板会优先出现在符合类目要求的小程序的公共模板库中。</p>
</blockquote>
<h3 id="模板管理界面示意图"><a href="#模板管理界面示意图" class="headerlink" title="模板管理界面示意图"></a>模板管理界面示意图</h3><p><img src="/images/subscrib.png" alt="小程序订阅模板示意"></p>
<hr>
<h3 id="小程序推送使用场景说明"><a href="#小程序推送使用场景说明" class="headerlink" title="小程序推送使用场景说明"></a>小程序推送使用场景说明</h3><ul>
<li><p><strong>基础订阅场景</strong><br>用户每完成一次订阅授权，开发者即可下发一条消息，<strong>没有时间限制</strong>。即使订阅与实际推送之间间隔很久，也不会失效。</p>
</li>
<li><p><strong>支付关联场景</strong><br>用户在小程序内完成微信支付后，开发者可基于支付订单触发<strong>服务通知</strong>，每笔订单最多可下发 <strong>3 条消息</strong>，该额度与普通订阅消息互不冲突。</p>
</li>
</ul>
<hr>
<h2 id="四、公众号消息推送说明"><a href="#四、公众号消息推送说明" class="headerlink" title="四、公众号消息推送说明"></a>四、公众号消息推送说明</h2><h3 id="公众号消息类型对比"><a href="#公众号消息类型对比" class="headerlink" title="公众号消息类型对比"></a>公众号消息类型对比</h3><table>
<thead>
<tr>
<th>公众号类型</th>
<th>模板消息支持</th>
<th>限制条件</th>
</tr>
</thead>
<tbody><tr>
<td>订阅号</td>
<td>❌ 不支持模板消息</td>
<td>仅支持图文或图文卡片消息</td>
</tr>
<tr>
<td>服务号</td>
<td>✅ 支持模板消息</td>
<td>需企业或组织认证</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 服务号每月可主动向用户推送 <strong>4 条模板消息</strong>，适合企业级服务与重要通知场景。</p>
</blockquote>
<hr>
<h2 id="五、核心流程图"><a href="#五、核心流程图" class="headerlink" title="五、核心流程图"></a>五、核心流程图</h2><p>以下为小程序&#x2F;服务号消息推送核心流程示意图：</p>
<p><img src="/images/xxts.drawio.png" alt="核心流程图"></p>
<hr>
<h2 id="六、总结对比"><a href="#六、总结对比" class="headerlink" title="六、总结对比"></a>六、总结对比</h2><table>
<thead>
<tr>
<th>项目</th>
<th>小程序订阅消息</th>
<th>服务号模板消息</th>
<th>公众号图文推送</th>
</tr>
</thead>
<tbody><tr>
<td>接收强度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>适用场景</td>
<td>支付提醒、任务提醒、系统通知等</td>
<td>用户服务通知</td>
<td>日常图文传播</td>
</tr>
<tr>
<td>限制</td>
<td>需用户主动订阅</td>
<td>企业认证</td>
<td>用户关注即可</td>
</tr>
<tr>
<td>模板多样性</td>
<td>模板需符合类目限制</td>
<td>模板较自由</td>
<td>图文内容为主</td>
</tr>
</tbody></table>
<hr>
<p>如需集成微信消息推送，请结合业务所属类目、目标用户行为和提醒紧急程度，选择最合适的推送方式，以实现更高的用户触达率和业务转化效果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/06/17/%E5%AE%89%E8%A3%85%20vscode%20SCSS%20IntelliSense%20%E6%8F%92%E4%BB%B6%E5%90%8E%EF%BC%8C$$%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/17/%E5%AE%89%E8%A3%85%20vscode%20SCSS%20IntelliSense%20%E6%8F%92%E4%BB%B6%E5%90%8E%EF%BC%8C$$%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">安装 vscode SCSS IntelliSense 插件后，$$符号问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-17 10:16:30 / 修改时间：10:21:48" itemprop="dateCreated datePublished" datetime="2025-06-17T10:16:30+08:00">2025-06-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ul>
<li>安装了SCSS IntelliSense ，输入 $,再选择，会多一个 $符号，如：   font-size:$$font-size-xs。有没有办法解决？</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li>终端输入命令，打开services文件夹 open &#x2F;Users&#x2F;apple&#x2F;.vscode&#x2F;extensions&#x2F;mrmlnc.vscode-scss-0.10.0&#x2F;out&#x2F;unsafe&#x2F;services</li>
<li>修改 parser.js 文件中的 findDocumentSymbols 方法</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   async function findDocumentSymbols(document, ast) &#123;</span><br><span class="line">    const symbols = ls.findDocumentSymbols(document, ast);</span><br><span class="line">    const links = await findDocumentLinks(document, ast);</span><br><span class="line">    const result = &#123;</span><br><span class="line">        functions: [],</span><br><span class="line">        imports: convertLinksToImports(links),</span><br><span class="line">        mixins: [],</span><br><span class="line">        variables: []</span><br><span class="line">    &#125;;</span><br><span class="line">    for (const symbol of symbols) &#123;</span><br><span class="line">        const position = symbol.location.range.start;</span><br><span class="line">        const offset = document.offsetAt(symbol.location.range.start);</span><br><span class="line">        if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Variable) &#123;</span><br><span class="line">            result.variables.push(&#123;</span><br><span class="line">                name: symbol.name.replace(&quot;$&quot;, &quot;&quot;), // 关键点</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                value: getVariableValue(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Method) &#123;</span><br><span class="line">            result.mixins.push(&#123;</span><br><span class="line">                name: symbol.name,</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                parameters: getMethodParameters(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Function) &#123;</span><br><span class="line">            result.functions.push(&#123;</span><br><span class="line">                name: symbol.name,</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                parameters: getMethodParameters(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/09/26/MongoDB-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/26/MongoDB-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">MongoDB 入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-09-26 20:33:05 / 修改时间：20:40:47" itemprop="dateCreated datePublished" datetime="2024-09-26T20:33:05+08:00">2024-09-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-安装-Homebrew"><a href="#1-安装-Homebrew" class="headerlink" title="1. 安装 Homebrew"></a>1. 安装 Homebrew</h3><p>如果还没有安装 Homebrew，可以使用以下命令安装 Homebrew：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可以访问 Homebrew 的 <a target="_blank" rel="noopener" href="https://brew.sh/">官方网站</a> 了解更多信息。</p>
<h3 id="2-使用-Homebrew-安装-MongoDB"><a href="#2-使用-Homebrew-安装-MongoDB" class="headerlink" title="2. 使用 Homebrew 安装 MongoDB"></a>2. 使用 Homebrew 安装 MongoDB</h3><h4 id="a-添加-MongoDB-官方-Homebrew-Tap"><a href="#a-添加-MongoDB-官方-Homebrew-Tap" class="headerlink" title="a. 添加 MongoDB 官方 Homebrew Tap"></a>a. 添加 MongoDB 官方 Homebrew Tap</h4><p>首先，运行以下命令来添加 MongoDB 官方的 Homebrew Tap（软件源）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br></pre></td></tr></table></figure>

<h4 id="b-安装-MongoDB-社区版"><a href="#b-安装-MongoDB-社区版" class="headerlink" title="b. 安装 MongoDB 社区版"></a>b. 安装 MongoDB 社区版</h4><p>接下来，使用 Homebrew 来安装 MongoDB 社区版：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mongodb-community@6.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>@6.0</code> 是 MongoDB 的版本号，你可以根据需要替换为其他版本。</p>
</blockquote>
<h3 id="3-启动-MongoDB-服务"><a href="#3-启动-MongoDB-服务" class="headerlink" title="3. 启动 MongoDB 服务"></a>3. 启动 MongoDB 服务</h3><p>安装完成后，可以通过 Homebrew 启动 MongoDB：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start mongodb/brew/mongodb-community</span><br></pre></td></tr></table></figure>

<p>这会将 MongoDB 作为 macOS 服务启动，并且会在每次系统启动时自动启动。</p>
<p>如果你只想手动启动 MongoDB 而不让它自动运行，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure>

<h3 id="4-检查-MongoDB-是否运行"><a href="#4-检查-MongoDB-是否运行" class="headerlink" title="4. 检查 MongoDB 是否运行"></a>4. 检查 MongoDB 是否运行</h3><p>你可以运行以下命令，查看 MongoDB 服务是否已经成功启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services list</span><br></pre></td></tr></table></figure>

<p>MongoDB 的状态应该显示为 “started”。</p>
<h3 id="5-连接-MongoDB"><a href="#5-连接-MongoDB" class="headerlink" title="5. 连接 MongoDB"></a>5. 连接 MongoDB</h3><p>MongoDB 服务器启动后，你可以通过 <code>mongo</code> 命令连接到 MongoDB 的命令行工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>如果一切正常，你现在应该已经连接到 MongoDB 的 shell，可以开始使用数据库了。</p>
<h3 id="6-停止-MongoDB-服务"><a href="#6-停止-MongoDB-服务" class="headerlink" title="6. 停止 MongoDB 服务"></a>6. 停止 MongoDB 服务</h3><p>如果你需要停止 MongoDB 服务，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services stop mongodb/brew/mongodb-community</span><br></pre></td></tr></table></figure>

<hr>
<p>这样，你就可以在 Mac 上成功安装和运行 MongoDB。如果遇到任何问题，请确保 Homebrew 和 MongoDB 的安装路径正确，并查看 Homebrew 提供的安装日志。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">面向对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-17 21:14:25" itemprop="dateCreated datePublished" datetime="2024-06-17T21:14:25+08:00">2024-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="认识对象"><a href="#认识对象" class="headerlink" title="认识对象"></a>认识对象</h2><ol>
<li>认识对象<ul>
<li>对象（object） 是键值对的集合，表示属性和值的映射关系</li>
<li>对象的语法：k和v之间用冒号分割，每组k:v之间用逗号分割，最后一个k:v对后可以不书写逗号</li>
<li><strong>属性名是否加引号？：如果对象的属性名不符合JS标识符命名规范，则这个键名必须用引号包裹</strong></li>
<li><strong>属性的访问：可以用“点语法”访问对象中指定键的值，如果属性名不符合JS标识符命名规范，则必须用方括号的写法来访问；如果属性名以变量形式存储，则必须使用方括号形式</strong></li>
<li>属性的更改：直接使用赋值运算符对某属性复制即可更改属性</li>
<li>属性的创建：如果对象本身没有某个属性值，则用点语法赋值时，这个属性就会被创建出来</li>
<li>属性的删除：如果要删除某个对象的属性，则需要用delete操作符</li>
</ul>
</li>
<li>对象的方法<ul>
<li>如果某个属性值是函数，则它也被称之为对象的“方法”</li>
<li>方法也是函数，只不过方法是对象的“函数属性”，它需要对象打点使用</li>
</ul>
</li>
<li>对象的遍历<ul>
<li>和遍历数组类似，对象也可以被遍历，遍历对象需要使用 for…in….循环</li>
<li>使用 for…in…循环、Object.keys() 等 可以遍历对象每个键</li>
</ul>
</li>
<li><strong>对象的深浅克隆（面试）</strong><ul>
<li>基本类型值和引用类型值<ul>
<li>基本类型值<ul>
<li>数字、字符串、布尔、undefined、null</li>
<li>内存中产生新的副本</li>
<li>比较值是否相等</li>
</ul>
</li>
<li>引用类型值<ul>
<li>对象、数组等</li>
<li><strong>内存中不产生新的副本，而是让变量指向同一个对象</strong></li>
<li><strong>比较内存地址是否相同，即比较是否为同一对象</strong></li>
</ul>
</li>
</ul>
</li>
<li>对象也是引用类型值<ul>
<li>不能通过var obj2 &#x3D; obj1 这样的语法克隆一个对象</li>
<li>使用 &#x3D;&#x3D; 或者 &#x3D;&#x3D;&#x3D; 进行对象的比较时，比较的是它们是否为内存中的同一个对象，而不是比较值是否相同</li>
</ul>
</li>
<li>浅克隆：只克隆对象的“表层”，如果对象的某些属性值又是引用类型值，则不进行一步克隆它，而是引用它</li>
<li>对象的深克隆：克隆对象的全貌，无论对象的属性值是否又是引用类型值，都能将它们实现克隆</li>
<li>和数组的深克隆类似，对象的深克隆需要使用递归</li>
</ul>
</li>
</ol>
<h2 id="认识函数的的上下文"><a href="#认识函数的的上下文" class="headerlink" title="认识函数的的上下文"></a>认识函数的的上下文</h2><ol>
<li>什么是上下文<ul>
<li>函数的上下文：函数中可以使用 this 关键字，它表示函数的上下文</li>
<li>与中文中“这”类似，函数中的 this 具体指代什么必须通过调用函数时的“前言后语”来判断</li>
<li><strong>普通函数的上下文是调用使用才能确定的，并且规则很多，但是箭头函数的上下文是定义时候确定的。</strong></li>
<li><strong>函数的上下文由调用方式决定</strong><ul>
<li>同一个函数，用不同的形式调用他，则函数的上下文不同</li>
<li><strong>函数只有被调用的时候，它的上下文才能被确定</strong></li>
<li>函数的上下文（this关键字）由调用函数的方式决定，function是“运行时上下文”策略</li>
<li>函数如果不调用，则不能确定函数的上下文</li>
</ul>
</li>
</ul>
</li>
<li>6种上下文规则<ul>
<li><strong>规则1：对象打点调用它的方法函数，则函数的上下文是这个打点的对象</strong><ul>
<li>对象.方法()</li>
</ul>
</li>
<li><strong>规则2：圆括号直接调用函数，则函数上下文是window对象</strong><ul>
<li>函数()</li>
</ul>
</li>
<li><strong>规则3：数组（类数组对象）枚举出函数进行调用，上下文是这个数组（类数组对象）</strong><ul>
<li>数组<a href="">下标</a></li>
<li>类数组对象<ul>
<li>什么是类数组对象：所有键名为自然数序列（从0开始），且有length属性的对象</li>
<li>argument对象是最常见的类数组对象，它是函数的实参列表</li>
</ul>
</li>
</ul>
</li>
<li><strong>规则4：IIFE中的函数，上下文是window对象</strong><ul>
<li>IIFE：立即可执行函数</li>
<li><code>(function()&#123; ...  &#125;)()</code></li>
</ul>
</li>
<li><strong>规则5：定时器、延时器调用函数，上下文是window对象</strong><ul>
<li>setInterval(函数,时间)</li>
<li>setTimeout(函数,时间)</li>
</ul>
</li>
<li><strong>规则6：事件处理函数的上下文是绑定事件的DOM元素</strong><ul>
<li><code>DOM元素.onclick = function()&#123; ... &#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>call和apply (call 呼叫,打电话，apply 应用，申请)<ul>
<li>call 和 apply 能指定函数的上下文 <ul>
<li>函数.call(上下文)</li>
<li>函数.apply(上下文)</li>
</ul>
</li>
<li>call 和 apply 区别<ul>
<li>只有在函数有参数的时候才能被体现出来</li>
<li>1、call 要用逗号罗列参数 ；2、apply 要把参数写到数组中</li>
</ul>
</li>
</ul>
</li>
<li>上下文规则总结（规则&#x2F;上下文）<ul>
<li>对象.函数() <ul>
<li>对象</li>
</ul>
</li>
<li>函数()<ul>
<li>window</li>
</ul>
</li>
<li>数组<a href="">下标</a> <ul>
<li>数组</li>
</ul>
</li>
<li>IIFE<ul>
<li>window</li>
</ul>
</li>
<li>定时器、延时器<ul>
<li>window</li>
</ul>
</li>
<li>DOM事件处理函数<ul>
<li>绑定DOM的元素</li>
</ul>
</li>
<li>call 和 apply<ul>
<li>任意指定</li>
</ul>
</li>
<li>用 new 调用函数<ul>
<li>秘密创建出的对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li>用new调用函数四布走<ul>
<li>用 new 调用函数的执行步骤和它的上下文弄清楚</li>
<li><strong>JS 规定，使用new操作符调用函数会进行“四步走”：</strong><ul>
<li>1、函数体内会自动创建出一个空白对象</li>
<li>2、函数的上下文（this）会指向这个对象</li>
<li>3、函数体内的语句会执行</li>
<li>4、函数会自动返回上下文对象，即使函数没有return语句</li>
</ul>
</li>
</ul>
</li>
<li>构造函数<ul>
<li>构造函数是一种特殊类型的函数，它在创建对象时被调用。它的主要目的是初始化对象的属性和方法。在JavaScript中，构造函数通常使用关键字<code>class</code>或<code>function</code>定义，并使用<code>new</code>关键字来创建对象。构造函数可以接受参数，这些参数可以用于设置对象的属性。</li>
</ul>
</li>
<li>类和实例<ul>
<li>类好比是“蓝图”，类只描述对象会拥有哪些属性和方法，但是并不具体指明属性的值。</li>
<li>实例是具体的对象</li>
<li>JavaScript中的构造函数可以类比于OO语言中的“类”，写法的确类似，但和真正的OO语言还是有本质的不同</li>
</ul>
</li>
</ol>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ol>
<li>继承<ul>
<li>实现继承的关键在于：子类必须拥有父类的全部属性和方法，同时子类还能定义自己特有的属性和方法。</li>
<li>1、原型链继承<ul>
<li>使用方法：<ul>
<li>子类的 prototype （原型） &#x3D;  new 父类()</li>
<li><strong>让子类的构造函数的 prototype ，指向父类的一个实例</strong></li>
<li>使用 Javascript 特有的原型链特性来实现继承，是普遍的做法</li>
</ul>
</li>
<li>存在的问题：<ul>
<li>问题2：子类的构造函数中，往往需要重复定义很多超类（父类、基类）定义过的属性，即，子类的构造函数写的不够优雅</li>
<li>问题1：如果父类的属性中有引用类型值，则这个属性会被所有子类的实例共享</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>2、构造函数继承（伪造对象、经典继承）<ul>
<li>使用方法：<ul>
<li><code>Parent.call(this, name);</code></li>
</ul>
</li>
<li>存在的问题：<ul>
<li><em><strong>借用构造函数的思想非常简单：在子类构造函数的内部调用超类的构造函数，但是要注意使用 call() 绑定上下文</strong></em></li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>3、组合继承<ul>
<li>使用方法：<ul>
<li><code>Parent.call(this, name);</code></li>
<li><code>Child.prototype = new Parent();</code></li>
</ul>
</li>
<li>存在问题：<ul>
<li>将借用原型链和借用构造函数的技术组合到一起，叫做组合继承，也叫做伪经典继承</li>
<li>组合继承是 JavaScript 中最常用的继承方式</li>
<li>组合继承继承的问题：组合继承最大的问题就是无论在什么情况下，都会调用两次超类的构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数的内部</li>
<li>构造函数继承和组合继承的区别在于： - 构造函数继承通过在子类构造函数内部调用父类构造函数来实现属性的继承，但无法继承父类原型链上的方法。 - 组合继承则是结合了原型链继承和构造函数继承的优点，通过调用父类构造函数来实现属性的继承，并且通过将子类的原型指向父类的实例来继承父类的方法。</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>4、原型式继承<ul>
<li>使用方法：<ul>
<li><code>var child = Object.create(parent);</code></li>
</ul>
</li>
<li>存在问题：<ul>
<li><strong>Object.create() 方法，可以根据指定的对象为原型创建出新对象，兼容性大于IE9</strong></li>
<li>在没有必要“兴师动众”地创建构造函数，而只是想让新对象与现有对象“类似”的情况下，使用 Object.create() 即可胜任，称为原型式继承</li>
<li>Object.create() 的兼容性写法<ul>
<li>如何在低版本浏览器中实现 object.create() 呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个临时构造函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 让这个临时构造函数的 prototype 指向o，这样一来它 new 出来的对象，__prototype__ 指向了o</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">    <span class="comment">// 返回 F 的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">object</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">__proto__</span> === obj1)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">b</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">   <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>5、寄生式继承<ul>
<li>使用方法：<ul>
<li>编写一个函数，它接收一个参数o，返回以o为原型的新对象p，同时给p上添加预置的新方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;悠悠&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(o)</span><br><span class="line">    p.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，正在睡觉`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">f</span>(o1)</span><br><span class="line">p1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">88</span>)</span><br><span class="line">p1.<span class="title function_">sayHello</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">f</span>(o2)</span><br><span class="line">p2.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p2&quot;</span>,p2)</span><br></pre></td></tr></table></figure></li>
<li>寄生式继承就是编写一个函数，它可以“增强对象”，只要把对象传入这个函数，这个函数将以此对象为“基础”创建出新对象，并为新对象赋予新的预置方法</li>
<li>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式</li>
</ul>
</li>
<li>存在问题：<ul>
<li>缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，即“方法没有写到 prototype 上”</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">createChild</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">    child.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi from Child&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">createChild</span>(parent);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>6、寄生组合式继承<ul>
<li>使用方法：<ul>
<li><strong>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已，本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受两个函数，子类构造函数、父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">33</span>, <span class="number">44</span>, <span class="number">56</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello 我是&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;在睡觉&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, sex, age, no, scholl</span>) &#123;</span><br><span class="line">    <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, sex, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">no</span> = no;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scholl</span> = scholl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用我们自己写的 inheritPrototype 函数，让 Student 类的 prototype 指向以 People.prototype 为原型的一个新对象</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">People</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">study</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exam</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">14025123</span>, <span class="string">&#x27;wenzhou&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure></li>
<li>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</li>
</ul>
</li>
<li>存在问题：<ul>
<li>寄生组合式继承的主要缺点是： 1. 虽然解决了组合继承中多次调用父类构造函数的问题，但仍然会调用一次父类构造函数来创建原型。 2. 增加了代码的复杂度，相比其他继承方式，可读性较差。</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">   prototype.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">   <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>instanceof 运算符<ul>
<li>用来检测“某个对象”对象是不是某个类的实例</li>
<li>底层机理：检查 Student.prototype 属性是否在 xiaoming 的原型链上（多少层都是，只要在就行）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming instaceof <span class="title class_">Student</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>原型链的终点<ul>
<li><em><strong>原型链的终点是 Object.prototype。 Object.prototype 是所有 JavaScript 对象的顶层原型，它是原型链的终点。</strong></em></li>
</ul>
</li>
<li>在prototype上添加方法<ul>
<li>People.prototype.方法 &#x3D; function(){ … }</li>
</ul>
</li>
<li>prototype在原型链查找<ul>
<li><strong>Javascript规定：实例可以打点访问它的原型的属性和方法，这被称为“原型链查找”</strong></li>
<li>遮蔽效应：如果实例上已经有属性和方法，则不往原型链上查找</li>
</ul>
</li>
<li>什么是prototype？<ul>
<li>任何函数都有prototype属性，prototype是英语“原型”的意思</li>
<li>prototype 属性值是个对象，它默认拥有 constructor 属性指回函数</li>
<li><strong>普通函数的 prototype 属性没有任何用处，而构造函数的 prototype 属性非常有用</strong></li>
<li><em><strong>构造函数的 prototype 属性是它实例的原型</strong></em></li>
</ul>
</li>
<li>hasOwnProperty<ul>
<li>hasOwnProperty 方法可以检查对象是否真正“自己拥有”某属性或者方法<ul>
<li>实例.hasOwnProperty(‘属性|方法’)</li>
</ul>
</li>
</ul>
</li>
<li>in<ul>
<li>in 运算符只能检查某个属性或方法是否可以被对象访问，不能检查是否自己的属性或方法<ul>
<li>语法：’属性|方法’ in 实例</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="上升到面向对象"><a href="#上升到面向对象" class="headerlink" title="上升到面向对象"></a>上升到面向对象</h2><ol>
<li>面向对象的本质：定义不同的类，让类的实例工作</li>
<li>面向对象的优点：程序编写更清晰、代码结构更严密、使代码更健壮更利于维护</li>
<li>面向对象经常用到的场合：需要封装和复用性的场合（组件思维）</li>
</ol>
<h2 id="JS的内置对象"><a href="#JS的内置对象" class="headerlink" title="JS的内置对象"></a>JS的内置对象</h2><ol>
<li>Date对象<ul>
<li>使用 new Date() 即可得到当前时间的日期对象，它是 object 类型值</li>
<li>使用 new Date(2020,11,1) 即可得到指定日期的日期对象，注意第二个参数表示月份，从0开始算，11表示12月<ul>
<li>这种写法不算时区</li>
</ul>
</li>
<li>也可以是 new Date(‘2020-12-01’)  这样的写法，月份，日期不足两位要补零<ul>
<li>按照字符串的写法，月份不是从0开始算，12月就是12月</li>
<li>这种写法算时区，中国属于东八区</li>
</ul>
</li>
<li>日期对象的常见方法<ul>
<li>getDate() 得到日期 1 ~ 31</li>
<li>getDay()  得到星期 0 ~ 6</li>
<li>getMonth()  得到月份 0 ~ 11</li>
<li>getFullYear()  得到年份 </li>
<li>getHours()  得到小时数 0 ~ 23</li>
<li>getMinutes()  得到分钟数 0 ~ 59</li>
<li>getSeconds()  得到秒数 0 ~ 59</li>
</ul>
</li>
<li>时间戳<ul>
<li>时间戳表示1970年1月1日零点整距离某时刻的毫秒数</li>
<li>通过 getTime() 方法或者 Date.parse() 函数可以将日期对象变为时间戳<ul>
<li>getTime() 精确到毫秒</li>
<li>Date.parse() 精确到秒</li>
</ul>
</li>
<li>通过 new Date(时间戳)  的写法，可以将时间戳变为日期对象</li>
</ul>
</li>
</ul>
</li>
<li>包装类<ul>
<li>Number()、String()、Boolean() 分别是数字、字符串、布尔值的“包装类”</li>
<li>很多编程语言都有“包装类”的设计，包装类的目的就是为了让基本类型值可以从他们的构造函数的prototype上获得方法</li>
<li>Number()、String()、Boolean() 的实例都是 object 类型，它们的 PrimitiveValue 属性存储的它们本身值<ul>
<li>PrimitiveValue 属性不可以自己打点访问，它是一个内部属性值</li>
</ul>
</li>
<li>new 出来的基本类型值可以正常参与运算</li>
<li>Array 不能成为数组的包装类 ，包装类是对基本类型的面向对象封装，而 Array 本身就不是基本类型值（而是引用类型值），所以就谈不上包装了，undefined、null 是没有包装类的</li>
</ul>
</li>
<li>Math对象<ul>
<li>幂和开方<ul>
<li>Math.pow()、Math.sqrt()</li>
</ul>
</li>
<li>向上取整和向下取整<ul>
<li>Math.ceil()、Math.floor()</li>
</ul>
</li>
<li>四舍五入方法<ul>
<li>Math.round()</li>
</ul>
</li>
<li>Math.max() 和 Math.min()<ul>
<li>Math.max() 可以得到参数列表最大值</li>
<li>Math.min() 可以得到参数列表最小值</li>
<li>Math.max() 要求参数必须是“罗列出来”，而不能是数组<ul>
<li>用 ES6 展开运算符</li>
<li>Math.max.apply(null,arr)</li>
</ul>
</li>
</ul>
</li>
<li>随机数 Math.random()<ul>
<li>Math.random() 可以得到 0 ~ 1之间的小数</li>
<li>为了得到 [a，b] 区间内的整数，可以使用这个公式 <ul>
<li><code>parseInt(Math.random() * (b - a + 1))  + a</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="JS的内置构造函数"><a href="#JS的内置构造函数" class="headerlink" title="JS的内置构造函数"></a>JS的内置构造函数</h2><ol>
<li>Javascript 有很多内置构造函数，比如Array就是数组的构造函数，Function 就是函数类型的构造函数，Object 就是对象类型的构造函数<ul>
<li>任何数组的字面量都可以看做是Array的实例</li>
<li>拓展数组的求和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展求和方法</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            count += arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">sum</span>())</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>内置的构造函数非常有用，所有该类型的方法都是定义在它的内置构造函数的 prototype 上的，我们可以给这个对象添加新的方法，从而拓展某类型的功能</li>
<li>内置构造函数的关系<ul>
<li><strong>Object.prototype 是万物原型链的终点。Javascript 中函数、数组皆为对象。</strong></li>
<li>任何函数都可以看做是 Function “new 出来的”，那我们开一个脑洞：Object 也是函数呀，它是不是 Function “new 出来的呢”？答案是肯定的</li>
</ul>
</li>
</ol>
<h2 id="重点内容"><a href="#重点内容" class="headerlink" title="** *重点内容 **"></a>** *重点内容 **</h2><ol>
<li>熟悉每条函数上下文 this 的判定规则<ul>
<li><strong>函数上下文 this 取决于函数如何被调用，而不是函数如何被定义</strong></li>
</ul>
</li>
<li>call 和 apply 的功能和区别</li>
<li>用 new 调用函数的四步走</li>
<li>什么是类和实例？面向对象编程的意义</li>
<li>prototype 和原型链查找</li>
<li>继承的实例、有哪些继承的方法？</li>
<li>使用面向对象实现小案例</li>
<li>熟练掌握 Math、Date等 JS 内置对象</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/15/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">流程控制语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-15 22:44:38" itemprop="dateCreated datePublished" datetime="2024-06-15T22:44:38+08:00">2024-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ol>
<li>if 语句的基本使用 <ul>
<li>如果…..就…..否则</li>
</ul>
</li>
<li>if elseif 多条件分支<ul>
<li>else if() 条件分支“暗含”不符合之前的所有条件，要深刻理解什么叫“否则如果”</li>
</ul>
</li>
<li>if 语句算法题</li>
<li>switch 语句<ul>
<li>用途：当一个变量被分类讨论的情形</li>
</ul>
</li>
<li>三元运算符<ul>
<li>条件表达式 ? 表达式1 : 表达式2</li>
<li>三元运算的用途：根据某个条件是否成立，在两个不同值中选择变量的值</li>
</ul>
</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ol>
<li>for 循环语句<ul>
<li>循环通常需要三个参数：起始值、结束值和步长。这些参数可以用for循环来指定。</li>
</ul>
</li>
<li>for 循环算法题<ul>
<li><em><strong>for循环有明确的范围，while循环没有明确的范围</strong></em></li>
</ul>
</li>
<li>while 循环语句<ul>
<li>while 语句 也是一种循环结构，是一种“不定范围”循环，和for循环各有不同的勇武之地</li>
<li>几乎所有编程语言，都提供了for和while语句</li>
<li><em><strong>while 语句事先不指定循环开始、结束范围，只要测试条件满足，就一直执行循环体</strong></em></li>
<li>while 循环没有显式定义循环变量，必须自己在while循环外先定义好循环变量，有时甚至可以没有循环变量</li>
<li>循环体内的语句，必须使循环测试条件趋向不成立，否侧会死循环。</li>
<li>while 循环，while 是 “当”的意思。</li>
<li>更适合while循环的场景<ul>
<li>寻找最小满足n²&gt;456789的整数n</li>
</ul>
</li>
</ul>
</li>
<li>break 和 continue <ul>
<li>break 表示立即终止循环，它只能用在循环语句中，在for循环和while循环中都可以使用</li>
<li>continue 用于 跳过循环中的一个迭代，并继续执行循环中的下一个迭代。for循环更经常使用continue</li>
</ul>
</li>
<li>do while 语句<ul>
<li>是一种“后测试循环语句”，它不同于for循环和while循环每次都是“先测试条件是否满足，然后执行循环体”，do-while循环是“先执行循环体，再测试条件是否满足”</li>
<li>do { 循环体 } while (循环执行条件)</li>
</ul>
</li>
<li>while 语句算法题</li>
</ol>
<h2 id="初识算法"><a href="#初识算法" class="headerlink" title="初识算法"></a>初识算法</h2><ol>
<li>什么是算法<ul>
<li>指的是解题方案的准确而完整的描述。是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制，也就是说，能够对一定规范的输入，在有限的实际内获得所要求的的输出。</li>
<li>算法就是把一个问题，拆解成计算机能够一步一步执行的步骤。</li>
<li>计算机的流程控制语句：顺序执行，选择语句，循环语句。</li>
<li>优秀算法的要求<ul>
<li>正确性</li>
<li>健壮性</li>
<li>可读性</li>
</ul>
</li>
</ul>
</li>
<li>累加器和累乘器</li>
<li>穷举法</li>
<li>综合算法题目</li>
<li>随机数函数<ul>
<li>得到[a,b]区间的整数，公式：</li>
<li><code>parseInt(Math.random()* (b-a + 1)) + a</code></li>
</ul>
</li>
</ol>
<h2 id="如何拆位"><a href="#如何拆位" class="headerlink" title="如何拆位"></a>如何拆位</h2><ol>
<li>数学方法<ul>
<li><code>百位是原数字除以100取整  Math.floor(n/100)</code></li>
<li><code>十位是原数字除以10取整，再与10求模  Math.floor(n/10) % 10</code></li>
<li><code>个位是原数字与10求模  n % 10</code></li>
</ul>
</li>
<li>字符串方法<ul>
<li>直接将原数字 变为字符串，然后再用charAt()方法得到每个数位的值</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/15/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/15/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E5%99%A8/" class="post-title-link" itemprop="url">定时器和延时器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-15 22:34:38" itemprop="dateCreated datePublished" datetime="2024-06-15T22:34:38+08:00">2024-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol>
<li>setInterval()  函数可以重复调用一个函数，在每次调用之间具有固定的时间间隔<ul>
<li>第一个参数是函数</li>
<li>第二个参数是间隔时间，以毫秒为单位，1000毫秒是1秒</li>
<li>函数可以接受3，4….个参数，它们将按照顺序传入函数</li>
<li>具名函数也可以传入serInterval （有名称的函数），但是不能加上括号，不加括号说明传入是 函数，加括号说明是传入执行体（会立即执行，起不到定时执行的效果）</li>
</ul>
</li>
</ol>
<h2 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h2><ol>
<li>clearInterval() 函数可以清除定时器，入参传入定时器名称</li>
</ol>
<h2 id="延时器"><a href="#延时器" class="headerlink" title="延时器"></a>延时器</h2><ol>
<li>setTimeout() 函数可以设置一个延时器，当指定时间到了之后，会执行函数一次，不会重复执行</li>
<li>clearTimeout() 函数可以清除延时器</li>
</ol>
<h2 id="初步认识异步语句"><a href="#初步认识异步语句" class="headerlink" title="初步认识异步语句"></a>初步认识异步语句</h2><ol>
<li>setInterval 和 setTimeout 是两个异步语句</li>
<li>异步（asynchronous）: 不会阻塞CPU继续执行其它语句，当异步完成时，会执行“回调函数”（callback）</li>
</ol>
<h2 id="使用定时器实现动画"><a href="#使用定时器实现动画" class="headerlink" title="使用定时器实现动画"></a>使用定时器实现动画</h2><ol>
<li>使用定时器实现动画较为不便：<ul>
<li>1、不方便根据动画总时间计算步长</li>
<li>2、运动方向要设置正负</li>
<li>3、多种运动进行叠加较为困难（比如一个放下一边移动一边变为圆形）</li>
</ul>
</li>
</ol>
<h2 id="JS和CSS3结合实现动画"><a href="#JS和CSS3结合实现动画" class="headerlink" title="JS和CSS3结合实现动画"></a>JS和CSS3结合实现动画</h2><ol>
<li>CSS3的transition过渡属性可以实现动画</li>
<li>JavaScript可以使用css3的transtion属性轻松实现元素动画</li>
<li>JS和CSS3结合实现动画规避了定时器制作动画的缺点</li>
</ol>
<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><ol>
<li>一个函数执行一次后，只有大于设定的执行周期后才允许执行第二次</li>
<li>函数节流非常容易实现，只需要借助setTimeout()延时器</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/15/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/15/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-title-link" itemprop="url">表达式与操作符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-15 21:21:13" itemprop="dateCreated datePublished" datetime="2024-06-15T21:21:13+08:00">2024-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JS-基本表达式"><a href="#JS-基本表达式" class="headerlink" title="JS 基本表达式"></a>JS 基本表达式</h2><ol>
<li>算数表达式<ul>
<li><code>+ 加</code><ul>
<li>加号有“加法”和“连字符”两种作用</li>
<li>如果加号两边操作数都是数字，则为“加法”，否则为连字符</li>
</ul>
</li>
<li><code>- 减</code></li>
<li><code>* 乘</code></li>
<li><code>/ 除</code></li>
<li><code>% 取余</code><ul>
<li>a % b 表示求 a 除以 b 的余数，它不关心整数部分，只关心余数</li>
</ul>
</li>
<li>默认情况，乘除法的优先级要高于加法和减法；必要时可以使用<strong>圆括号</strong>来改变运算的顺序</li>
<li>隐式类型转换<ul>
<li>如果参与数学运算的某操作数不是数字型，那么Javascript会自动将此操作数转换为数字型（不包括 加号 运算符）</li>
<li><code>例：3 * &quot;4&quot; //  12</code></li>
<li>隐式转换的本质是内部调用 Number() 函数</li>
</ul>
</li>
</ul>
</li>
<li>关系表达式<ul>
<li>大于 &gt;</li>
<li>小于 &lt;</li>
<li>大于或等于 &gt;&#x3D;</li>
<li>小于或等于 &lt;&#x3D;</li>
<li>等于 &#x3D;&#x3D;</li>
<li>不等于 !&#x3D;</li>
<li>全等于 &#x3D;&#x3D;&#x3D;</li>
<li>不全等于 !&#x3D;&#x3D;</li>
<li>null 和 undefined 用 &#x3D;&#x3D; 进行比较涉及隐式强制类型转换，ES5规范中规定<ul>
<li>如果 x 为null ，y为 undefined，则结果为true</li>
<li>如果x为undefined,y为null，则结果为true</li>
<li>null 和 undefined 用 &#x3D;&#x3D;&#x3D; 比较时结果为false，是因为类型不同</li>
<li>typeof null -&gt; object</li>
<li>typeof undefined -&gt; undefined</li>
</ul>
</li>
<li>NaN 不自等<ul>
<li>如何判断某个值为 NaN ，isNaN</li>
</ul>
</li>
</ul>
</li>
<li>逻辑表达式<ul>
<li>或<ul>
<li>|| 有真就真</li>
</ul>
</li>
<li>与<ul>
<li>&amp;&amp;  都真才真</li>
</ul>
</li>
<li>非<ul>
<li>! 表示 “非”，也可以称为“置反运算”</li>
<li>! 是一个“单目运算符”，只需要一个操作数</li>
<li>置反运算的结果一定是布尔值</li>
<li><em><strong>!! 两个叹号是将这个值的相应布尔值展现出来</strong></em></li>
</ul>
</li>
<li>短路计算（面试）<ul>
<li><code>例：3 &amp;&amp; 6 ，结果为 6，  3 || 6 ，结果为 3</code></li>
</ul>
</li>
<li><strong>逻辑运算顺序的优先级是： 非 -&gt;  与 -&gt; 或</strong></li>
</ul>
</li>
<li>赋值表达式<ul>
<li>赋值  &#x3D;</li>
<li>快捷赋值<ul>
<li>+&#x3D;</li>
<li>-&#x3D;</li>
<li>*&#x3D;</li>
<li>&#x2F;&#x3D;</li>
<li>%&#x3D;</li>
</ul>
</li>
<li>自增运算<ul>
<li>++</li>
<li>a++ 先用再加，++a 先加再用</li>
<li><strong>面试题：var a &#x3D; 3, b&#x3D;4; alert(a++ + b++ + ++a + ++b)</strong></li>
</ul>
</li>
<li>自减运算 –</li>
</ul>
</li>
<li>综合表达式<ul>
<li><strong>运算顺序：非运算 -&gt; 数学运算 -&gt; 关系运算 -&gt; 逻辑运算</strong></li>
<li>变量的范围表示<ul>
<li>例如：验证变量 a 是否介于5到12之间。num1 &gt;&#x3D; 5 &amp;&amp; num1 &lt;&#x3D; 12</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><ol>
<li>5  +  3<ul>
<li>表达式 &#x3D; 操作数 运算符 操作数</li>
</ul>
</li>
</ol>
<h2 id="有关-IEEE754"><a href="#有关-IEEE754" class="headerlink" title="有关 IEEE754"></a>有关 IEEE754</h2><ol>
<li>Javascript 使用了 IEEE754 二进制浮点数算数标准，这会使一些个别的小数计算产生“丢失精度”问题</li>
<li>解决方法：在进行小数运算时候，要调用数字的toFixed()方法保留指定的小数位数</li>
<li>幂和开根号<ul>
<li>Javascript 没有提供幂计算、开根号的运算符。需要使用Math对象的相关方法进行计算。</li>
<li>Math.pow(2,3) 幂计算，2的3次方</li>
<li>Math.sqrt(81)  开根号运算符</li>
<li>向上取整  Math.ceil()</li>
<li>向下取整  Math.floor()</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/14/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/14/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Javascript 基本数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-14 19:41:46" itemprop="dateCreated datePublished" datetime="2024-06-14T19:41:46+08:00">2024-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据类型简介和检测"><a href="#数据类型简介和检测" class="headerlink" title="数据类型简介和检测"></a>数据类型简介和检测</h2><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol>
<li>null 类型<ul>
<li>表示“空”，它是“空对象”</li>
<li>当我们需要将对象销毁、数组销毁或者删除事件监听时，通常将它们设置为null<ul>
<li><code>box.click = null</code></li>
</ul>
</li>
<li><strong>使用 typeof 检测 null 值，结果是object，这点尤其要注意</strong></li>
<li>类型和typeof 检测结果并不是一一对应的，比如数组用typeof检测出来的结果也是object</li>
</ul>
</li>
<li>undefined 类型<ul>
<li>一个没有被复制的变量的默认值是undefined，而undefine的类型也是undefined</li>
<li>即：undefined又是值，又是一种类型，这种类型只有它自己一个值</li>
</ul>
</li>
<li>布尔类型  （Boolean）<ul>
<li>布尔型值只有两个：true 和 fasle，分别表示真和假</li>
</ul>
</li>
<li>字符串类型（String）<ul>
<li>字符串要用引号包裹，双引号或者单引号均可</li>
<li>加号可以用来拼接多个字符串</li>
<li>空字符串，直接写闭合的引号即可</li>
<li>字符串的 length 属性表示字符串的长度</li>
<li>字符串的常用方法<ul>
<li>charAt()<ul>
<li>得到指定位置字符</li>
</ul>
</li>
<li>substring()<ul>
<li>提取子串<ul>
<li>substring(a,b) 方法得到从 a 开始到b结束（不包含b处）的子串</li>
<li>如果省略第二个参数，返回字符串一直到字符串的结尾</li>
<li>substring(a,b) 中，a 可以大于 b ，数字顺序将自动调整为小数在前</li>
</ul>
</li>
</ul>
</li>
<li>substr()<ul>
<li>提取子串<ul>
<li>substr(a,b) 方法得到从 a 开始的 长度为b的子串<ul>
<li>子串的长度而不是编号</li>
</ul>
</li>
<li>substr(a,b) 方法 b 参数可以省略，表示到文档的结尾</li>
<li>substr(a,b) 方法中，a可以是负数，表示倒数位置</li>
</ul>
</li>
</ul>
</li>
<li>slice()<ul>
<li>提取子串<ul>
<li>slice(a,b) 方法得到从 a 开始到b结束（不包含b处）的子串</li>
<li>slice(a,b) 方法 a 参数可以是负数</li>
<li>slice(a,b) 方法 a 参数必须小于b</li>
</ul>
</li>
</ul>
</li>
<li>toUpperCase()<ul>
<li>将字符串变为大写</li>
</ul>
</li>
<li>toLowerCase()<ul>
<li>将字符串变为小写</li>
</ul>
</li>
<li>indexOf()<ul>
<li>检索字符串<ul>
<li>返回某个字符串值在首次出现的位置</li>
<li>如果检测的字符串值没有出现，则返回-1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数字类型（Number）<ul>
<li>所有数字不分大小、不分整浮、不分正负、都是数字类型</li>
<li>小数中，零是可以省略的</li>
<li>较大数或较小数（绝对值比较小），可以写成科学计数法<ul>
<li>例：3e8、3e-4</li>
</ul>
</li>
<li>不同进制的数字<ul>
<li>二进制数值以0b开头  例：0b10</li>
<li>八进制数值以0开头  例：017</li>
<li>十六进制以0x开头  例如：0x156</li>
</ul>
</li>
<li>一个特殊的数字型值NaN<ul>
<li>NaN是英语 “not a number” 的 意思，即“不是一个数”，但它是一个数字类型的值</li>
<li>typeof NaN    &#x2F;&#x2F; number</li>
<li>0&#x2F;0 的结果就是NaN，事实上，在数学运算中，若结果不能得到数字，其结果往往都是NaN</li>
<li>NaN有一个“奇怪”的性质，不自等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><ol>
<li>其它值 -&gt; 数值<ul>
<li>Number() 系统内置的构造函数</li>
<li>parseInt() 函数</li>
<li>parseFloat() 函数</li>
</ul>
</li>
<li>其它值 -&gt; 字符串<ul>
<li>String() 函数 系统内置的构造函数</li>
<li>toString() 方法，几乎所有的值都有该方法</li>
<li><em>当数值直接调用 toString() 方法的时候，要加上括号 例：(5).toString()</em></li>
</ul>
</li>
<li>其它值 -&gt; 布尔值<ul>
<li>Boolean() 函数</li>
</ul>
</li>
</ol>
<h2 id="复杂数据类型简介"><a href="#复杂数据类型简介" class="headerlink" title="复杂数据类型简介"></a>复杂数据类型简介</h2><ol>
<li>对象  Object</li>
<li>方法 Function</li>
<li>复杂数据类型都是“引用类型”</li>
</ol>
<h2 id="typeof-运算符可以检测值或者变量的类型"><a href="#typeof-运算符可以检测值或者变量的类型" class="headerlink" title="typeof 运算符可以检测值或者变量的类型"></a>typeof 运算符可以检测值或者变量的类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">5</span>; </span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;shanmu&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>typeof 不是内置函数 是操作符</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/14/JS%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/14/JS%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">JS语法与变量</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-14 19:36:17" itemprop="dateCreated datePublished" datetime="2024-06-14T19:36:17+08:00">2024-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2><ol>
<li>alert</li>
<li>console</li>
</ol>
<h2 id="前端开发主要有哪些层，语言和功能是什么？"><a href="#前端开发主要有哪些层，语言和功能是什么？" class="headerlink" title="前端开发主要有哪些层，语言和功能是什么？"></a>前端开发主要有哪些层，语言和功能是什么？</h2><ol>
<li>HTML<ul>
<li>结构层  搭建骨架、描述页面语义</li>
</ul>
</li>
<li>CSS<ul>
<li>样式层</li>
</ul>
</li>
<li>Javascript<ul>
<li>行为层  表单验证、数据交互、数据收发等</li>
</ul>
</li>
</ol>
<h2 id="变量声明提升（面试题）"><a href="#变量声明提升（面试题）" class="headerlink" title="变量声明提升（面试题）"></a><strong>变量声明提升（面试题）</strong></h2><ol>
<li>你可以提前使用一个稍后才声明的变量，而不会引发异常</li>
<li>在执行所有代码前，JS有预解析阶段，会预读所有变量的定义</li>
<li>只提升定义，并不提升值</li>
<li>var 关键词可以变量提升， let 并不能</li>
<li>在实际开发中，一定要先定义变量赋值，再使用。</li>
</ol>
<h2 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么"></a>变量是什么</h2><ol>
<li>要定义变量，第一步就是声明它，并给它赋值</li>
<li>变量是计算机语言中能存储计算结果或能表示值抽象概念</li>
<li>变量不是数值本身，它们仅仅是一个用于存储数值的容器</li>
<li>标识符的命名规则（函数、类名、对象的属性也要遵守这个规则）<ul>
<li><strong>变量名大小写敏感，a和A两个不同的变量</strong></li>
<li><strong>不能是关键词或保留词</strong></li>
<li><strong>只能由字母、数字、下划线、$组成，但不能以数字开头</strong></li>
</ul>
</li>
<li>优秀的变量命名法<ul>
<li>驼峰命名法 例如：mathTestScore</li>
<li>c风格 例如：math_test_score</li>
<li>匈牙利命名法 例如：iMathTestScore ，第一个字母 i，提示变量类型</li>
</ul>
</li>
<li>变量的默认值<ul>
<li>一个变量只定义，但没有赋值，默认是undefined</li>
</ul>
</li>
<li>等号表示赋值</li>
<li>同时声明多个变量<ul>
<li>var a&#x3D;0,b&#x3D;0;</li>
</ul>
</li>
<li>var 定义的变量会被挂载在 window 上，let 不会</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">之乎泽野</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"zhihuzeye","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
