<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhihuzeye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="积跬步，至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="泽野之乡">
<meta property="og:url" content="https://zhihuzeye.github.io/index.html">
<meta property="og:site_name" content="泽野之乡">
<meta property="og:description" content="积跬步，至千里">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="之乎泽野">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhihuzeye.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>泽野之乡</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="泽野之乡" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">泽野之乡</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="之乎泽野"
      src="/images/face1.png">
  <p class="site-author-name" itemprop="name">之乎泽野</p>
  <div class="site-description" itemprop="description">积跬步，至千里</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhihuzeye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhihuzeye" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kydlyj@gmail.com" title="E-Mail → mailto:kydlyj@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/08/11/Next-js-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/Next-js-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Next.js App Router 特殊文件全解（Next.js 15 最新）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-11 14:20:00 / 修改时间：18:20:07" itemprop="dateCreated datePublished" datetime="2025-08-11T14:20:00+08:00">2025-08-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Next-js-App-Router-特殊文件大全（Next-js-15-最新）"><a href="#Next-js-App-Router-特殊文件大全（Next-js-15-最新）" class="headerlink" title="Next.js App Router 特殊文件大全（Next.js 15 最新）"></a>Next.js App Router 特殊文件大全（Next.js 15 最新）</h1><p>在 <strong>Next.js App Router</strong> 中，有一些文件名具有特殊含义，只要放在 <code>app</code> 目录的特定位置，Next.js 就会自动识别并应用对应功能。<br>本文将系统整理这些特殊文件的<strong>作用</strong>、<strong>使用方式</strong>和<strong>注意事项</strong>。</p>
<hr>
<h2 id="1-page-tsx-page-jsx"><a href="#1-page-tsx-page-jsx" class="headerlink" title="1. page.tsx &#x2F; page.jsx"></a>1. <code>page.tsx</code> &#x2F; <code>page.jsx</code></h2><p><strong>作用</strong>：定义当前路由的页面内容。</p>
<p><strong>使用方法</strong>：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项：-每个目录只能有一个-page-tsx。-必须是默认导出（default-export）。-与-layout-tsx-搭配可实现共享布局。"><a href="#注意事项：-每个目录只能有一个-page-tsx。-必须是默认导出（default-export）。-与-layout-tsx-搭配可实现共享布局。" class="headerlink" title="注意事项：- 每个目录只能有一个 page.tsx。- 必须是默认导出（default export）。- 与 layout.tsx 搭配可实现共享布局。"></a>注意事项：<br>- 每个目录只能有一个 page.tsx。<br>- 必须是默认导出（default export）。<br>- 与 layout.tsx 搭配可实现共享布局。</h2><h2 id="2-layout-tsx"><a href="#2-layout-tsx" class="headerlink" title="2. layout.tsx"></a>2. layout.tsx</h2><p><strong>作用</strong>： 定义当前路由及其子路由的共享布局。</p>
<h2 id="使用方法：注意事项：-接收-children-属性。-可嵌套，形成分层布局。-元数据可在-layout-tsx-中配置，作用于所有子页面。"><a href="#使用方法：注意事项：-接收-children-属性。-可嵌套，形成分层布局。-元数据可在-layout-tsx-中配置，作用于所有子页面。" class="headerlink" title="使用方法：注意事项：- 接收 children 属性。- 可嵌套，形成分层布局。- 元数据可在 layout.tsx 中配置，作用于所有子页面。"></a><strong>使用方法：</strong><br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">RootLayout</span>(<span class="params">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">header</span>&gt;</span>公共头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>公共底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意事项：<br>- 接收 children 属性。<br>- 可嵌套，形成分层布局。<br>- 元数据可在 layout.tsx 中配置，作用于所有子页面。</h2><h2 id="3-template-tsx"><a href="#3-template-tsx" class="headerlink" title="3. template.tsx"></a>3. template.tsx</h2><p><strong>作用</strong>： 类似布局，但不会缓存，每次导航都会重新渲染。</p>
<p>使用场景：</p>
<ul>
<li>需要强制刷新 UI 状态的布局，如动画过渡页面。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Template</span>(<span class="params">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;fade&quot;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>与 layout.tsx 不同，template.tsx 不会在客户端保留状态。</li>
<li>适合做页面切换动画或临时状态隔离。</li>
</ul>
<hr>
<h2 id="4-not-found-tsx"><a href="#4-not-found-tsx" class="headerlink" title="4. not-found.tsx"></a>4. not-found.tsx</h2><h2 id="作用：-定义当前路由下的-404-页面。注意事项：-只影响所在目录及子路由。-可在代码中调用-notFound-来触发。"><a href="#作用：-定义当前路由下的-404-页面。注意事项：-只影响所在目录及子路由。-可在代码中调用-notFound-来触发。" class="headerlink" title="作用： 定义当前路由下的 404 页面。注意事项：- 只影响所在目录及子路由。- 可在代码中调用 notFound() 来触发。"></a><strong>作用</strong>： 定义当前路由下的 404 页面。<br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">NotFound</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>页面不存在<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意事项：<br>- 只影响所在目录及子路由。<br>- 可在代码中调用 notFound() 来触发。</h2><h2 id="5-error-tsx"><a href="#5-error-tsx" class="headerlink" title="5. error.tsx"></a>5. error.tsx</h2><h2 id="作用：-捕获并渲染当前路由的运行时错误。注意事项：-必须是客户端组件（”use-client”）-reset-可重新渲染页面"><a href="#作用：-捕获并渲染当前路由的运行时错误。注意事项：-必须是客户端组件（”use-client”）-reset-可重新渲染页面" class="headerlink" title="作用： 捕获并渲染当前路由的运行时错误。注意事项：- 必须是客户端组件（”use client”）- reset() 可重新渲染页面"></a><strong>作用</strong>： 捕获并渲染当前路由的运行时错误。<br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Error</span>(<span class="params">&#123; error, reset &#125;: &#123; error: <span class="built_in">Error</span>; reset: () =&gt; <span class="built_in">void</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>出错了<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> reset()&#125;&gt;重试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意事项：<br>- 必须是客户端组件（”use client”）<br>- reset() 可重新渲染页面</h2><h3 id="6-loading-tsx"><a href="#6-loading-tsx" class="headerlink" title="6. loading.tsx"></a>6. loading.tsx</h3><h2 id="作用：-定义当前路由的加载状态-UI。注意事项：-会在页面加载或切换时自动显示。-适合与-流式渲染（Streaming）-搭配。"><a href="#作用：-定义当前路由的加载状态-UI。注意事项：-会在页面加载或切换时自动显示。-适合与-流式渲染（Streaming）-搭配。" class="headerlink" title="作用： 定义当前路由的加载状态 UI。注意事项：- 会在页面加载或切换时自动显示。- 适合与 流式渲染（Streaming） 搭配。"></a><strong>作用</strong>： 定义当前路由的加载状态 UI。<br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Loading</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意事项：<br>- 会在页面加载或切换时自动显示。<br>- 适合与 流式渲染（Streaming） 搭配。</h2><h2 id="7-default-tsx"><a href="#7-default-tsx" class="headerlink" title="7. default.tsx"></a>7. default.tsx</h2><p><strong>作用</strong>： 用于并行路由中定义默认子路由。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Default</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是默认视图<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>仅用于并行路由 (folder) 机制。</li>
</ul>
<hr>
<h2 id="8-route-ts-route-js"><a href="#8-route-ts-route-js" class="headerlink" title="8. route.ts &#x2F; route.js"></a>8. route.ts &#x2F; route.js</h2><p><strong>作用</strong>： 定义 API 路由（取代 pages&#x2F;api）。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Response</span>.<span class="title function_">json</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;Hello API&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>可导出 GET, POST, PUT, DELETE 等方法。</li>
<li>返回 Response 对象。</li>
</ul>
<hr>
<h2 id="9-head-tsx"><a href="#9-head-tsx" class="headerlink" title="9. head.tsx"></a>9. head.tsx</h2><p><strong>作用</strong>： 自定义 HTML <head> 内容。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Head</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网站<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;描述内容&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>仅在当前路由及子路由生效。</li>
<li>不推荐与 metadata API 混用。</li>
</ul>
<hr>
<h2 id="10-metadata-API（非文件，但常用）"><a href="#10-metadata-API（非文件，但常用）" class="headerlink" title="10. metadata API（非文件，但常用）"></a>10. metadata API（非文件，但常用）</h2><h2 id="作用：-配置页面-SEO-信息。"><a href="#作用：-配置页面-SEO-信息。" class="headerlink" title="作用： 配置页面 SEO 信息。"></a><strong>作用</strong>： 配置页面 SEO 信息。<br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> metadata = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;产品详情&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;这是产品详情页&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><h2 id="11-opengraph-image-tsx-twitter-image-tsx"><a href="#11-opengraph-image-tsx-twitter-image-tsx" class="headerlink" title="11. opengraph-image.tsx &#x2F; twitter-image.tsx"></a>11. opengraph-image.tsx &#x2F; twitter-image.tsx</h2><p><strong>作用</strong>： 动态生成社交分享图片。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ImageResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next/og&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> size = &#123; <span class="attr">width</span>: <span class="number">1200</span>, <span class="attr">height</span>: <span class="number">630</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Image</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImageResponse</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>分享图<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, &#123; <span class="attr">width</span>: <span class="number">1200</span>, <span class="attr">height</span>: <span class="number">630</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-icon-tsx-apple-icon-tsx-favicon-ico"><a href="#12-icon-tsx-apple-icon-tsx-favicon-ico" class="headerlink" title="12.  icon.tsx &#x2F; apple-icon.tsx &#x2F; favicon.ico"></a>12.  icon.tsx &#x2F; apple-icon.tsx &#x2F; favicon.ico</h2><h2 id="作用：-定义网站图标。"><a href="#作用：-定义网站图标。" class="headerlink" title="作用： 定义网站图标。"></a><strong>作用</strong>： 定义网站图标。<br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Icon</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">svg</span>&gt;</span>...<span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="13-manifest-webmanifest"><a href="#13-manifest-webmanifest" class="headerlink" title="13. manifest.webmanifest"></a>13. manifest.webmanifest</h2><p><strong>作用</strong>： PWA 应用清单。</p>
<p>⸻</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>文件名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>page.tsx</td>
<td>页面内容</td>
</tr>
<tr>
<td>layout.tsx</td>
<td>共享布局</td>
</tr>
<tr>
<td>template.tsx</td>
<td>非缓存布局</td>
</tr>
<tr>
<td>not-found.tsx</td>
<td>404 页面</td>
</tr>
<tr>
<td>error.tsx</td>
<td>错误处理</td>
</tr>
<tr>
<td>loading.tsx</td>
<td>加载状态</td>
</tr>
<tr>
<td>default.tsx</td>
<td>并行路由默认页</td>
</tr>
<tr>
<td>route.ts</td>
<td>API 路由</td>
</tr>
<tr>
<td>head.tsx</td>
<td>自定义 head</td>
</tr>
<tr>
<td>opengraph-image.tsx</td>
<td>分享图片</td>
</tr>
<tr>
<td>icon.tsx</td>
<td>网站图标</td>
</tr>
<tr>
<td>manifest.webmanifest</td>
<td>PWA 配置</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/08/11/Next-js-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%AF%BC%E8%88%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/Next-js-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%AF%BC%E8%88%AA/" class="post-title-link" itemprop="url">Next.js 链接与导航详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-11 11:33:20 / 修改时间：18:06:51" itemprop="dateCreated datePublished" datetime="2025-08-11T11:33:20+08:00">2025-08-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Next-js-链接与导航"><a href="#Next-js-链接与导航" class="headerlink" title="Next.js 链接与导航"></a>Next.js 链接与导航</h1><p>在 Next.js 中，导航分为两大类：</p>
<ol>
<li><strong>声明式导航</strong>（通过 <code>&lt;Link&gt;</code> 组件）</li>
<li><strong>命令式导航</strong>（通过 <code>useRouter</code> API）</li>
</ol>
<hr>
<h2 id="1-声明式导航"><a href="#1-声明式导航" class="headerlink" title="1. 声明式导航"></a>1. 声明式导航</h2><p>使用 <code>next/link</code> 实现页面跳转：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通跳转</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换当前历史记录（不会新增 history 记录）</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span> <span class="attr">replace</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-获取当前路径"><a href="#2-获取当前路径" class="headerlink" title="2. 获取当前路径"></a>2. 获取当前路径</h2><h2 id="在客户端组件中，可以用-usePathname-获取当前路由路径："><a href="#在客户端组件中，可以用-usePathname-获取当前路由路径：" class="headerlink" title="在客户端组件中，可以用 usePathname 获取当前路由路径："></a>在客户端组件中，可以用 usePathname 获取当前路由路径：<br><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;use client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; usePathname &#125; <span class="keyword">from</span> <span class="string">&#x27;next/navigation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">PathInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> pathname = <span class="title function_">usePathname</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当前路径：&#123;pathname&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="3-参数（params）与搜索参数（searchParams）"><a href="#3-参数（params）与搜索参数（searchParams）" class="headerlink" title="3. 参数（params）与搜索参数（searchParams）"></a>3. 参数（params）与搜索参数（searchParams）</h2><p>在 Next.js 的 page.tsx 中，可以通过 props 获取路由参数和查询参数。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端组件写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  params,</span></span><br><span class="line"><span class="params">  searchParams,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  params: <span class="built_in">Promise</span>&lt;&#123; articleId: <span class="built_in">string</span> &#125;&gt;;</span></span><br><span class="line"><span class="params">  searchParams: <span class="built_in">Promise</span>&lt;&#123; lang?: <span class="string">&#x27;zh&#x27;</span> | <span class="string">&#x27;en&#x27;</span> &#125;&gt;;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; articleId &#125; = <span class="keyword">await</span> params;</span><br><span class="line">  <span class="keyword">const</span> &#123; lang = <span class="string">&#x27;en&#x27;</span> &#125; = <span class="keyword">await</span> searchParams;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文章 ID: &#123;articleId&#125;，语言: &#123;lang&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端组件写法</span></span><br><span class="line"><span class="string">&#x27;use client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  params,</span></span><br><span class="line"><span class="params">  searchParams,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  params: <span class="built_in">Promise</span>&lt;&#123; articleId: <span class="built_in">string</span> &#125;&gt;;</span></span><br><span class="line"><span class="params">  searchParams: <span class="built_in">Promise</span>&lt;&#123; lang?: <span class="string">&#x27;zh&#x27;</span> | <span class="string">&#x27;en&#x27;</span> &#125;&gt;;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; articleId &#125; = <span class="title function_">use</span>(params);</span><br><span class="line">  <span class="keyword">const</span> &#123; lang = <span class="string">&#x27;en&#x27;</span> &#125; = <span class="title function_">use</span>(searchParams);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文章 ID: &#123;articleId&#125;，语言: &#123;lang&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h6><ul>
<li>params<br>动态路由参数，如 &#x2F;articles&#x2F;123 中的 articleId&#x3D;123</li>
<li>searchParams<br>查询参数，如 &#x2F;articles&#x2F;123?lang&#x3D;zh 中的 lang&#x3D;zh</li>
<li><strong>注意</strong>：</li>
<li>page.tsx 可以访问 params 和 searchParams</li>
<li>layout.tsx 只能访问 params，无法访问 searchParams</li>
</ul>
<hr>
<h2 id="4-命令式导航（程序化导航）"><a href="#4-命令式导航（程序化导航）" class="headerlink" title="4. 命令式导航（程序化导航）"></a>4. 命令式导航（程序化导航）</h2><p>在客户端组件中使用 useRouter 实现导航：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;use client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/navigation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Navigator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.push(&#x27;/path&#x27;)&#125;&gt;跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.replace(&#x27;/path&#x27;)&#125;&gt;替换跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.back()&#125;&gt;返回<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.refresh()&#125;&gt;刷新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<ul>
<li>router.push(path)：跳转到新路径</li>
<li>router.replace(path)：替换当前路径（不新增历史记录）</li>
<li>router.back()：返回上一页</li>
<li>router.refresh()：刷新当前页面数据</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>静态跳转 用 <Link></li>
<li>动态跳转 用 useRouter</li>
<li>params 获取动态路由参数</li>
<li>searchParams 获取查询参数（仅在页面可用）</li>
<li>布局组件（layout）无法获取查询参数</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/08/11/Next-js-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/Next-js-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Next.js 搜索引擎优化（SEO）——元数据配置详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-11 10:51:24 / 修改时间：18:00:23" itemprop="dateCreated datePublished" datetime="2025-08-11T10:51:24+08:00">2025-08-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="路由元数据（Metadata-API）"><a href="#路由元数据（Metadata-API）" class="headerlink" title="路由元数据（Metadata API）"></a>路由元数据（Metadata API）</h1><p>Next.js 中的 <strong>元数据 API</strong> 是一个非常强大的功能，它允许我们为每个页面定义元数据，从而在被 <strong>搜索引擎索引</strong> 或 <strong>社交平台分享</strong> 时，有更好的展示效果。</p>
<hr>
<h2 id="在-Next-js-中使用元数据的两种方式"><a href="#在-Next-js-中使用元数据的两种方式" class="headerlink" title="在 Next.js 中使用元数据的两种方式"></a>在 Next.js 中使用元数据的两种方式</h2><p>你可以在 <code>layout.tsx</code> 或 <code>page.tsx</code> 中定义元数据，方式有两种：</p>
<ol>
<li><strong>静态元数据对象</strong></li>
<li><strong>动态的 <code>generateMetadata</code> 函数</strong></li>
</ol>
<hr>
<h2 id="元数据规则"><a href="#元数据规则" class="headerlink" title="元数据规则"></a>元数据规则</h2><ul>
<li><code>layout.tsx</code> 和 <code>page.tsx</code> <strong>都可以</strong>导出元数据：<ul>
<li>布局元数据（layout）会应用到该布局下的所有页面</li>
<li>页面元数据（page）只应用于该页面</li>
</ul>
</li>
<li>元数据遵循 <strong>自上而下</strong> 的顺序，从根布局开始</li>
<li>当多个层级都定义了相同字段时，会 <strong>合并</strong> 元数据：<ul>
<li><strong>页面元数据</strong> 的优先级高于 <strong>布局元数据</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="静态元数据对象示例"><a href="#静态元数据对象示例" class="headerlink" title="静态元数据对象示例"></a>静态元数据对象示例</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> metadata = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;这是网站的首页描述&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="动态生成元数据示例"><a href="#动态生成元数据示例" class="headerlink" title="动态生成元数据示例"></a>动态生成元数据示例</h6><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Metadata</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">generateMetadata</span>(<span class="params">&#123; params &#125;: Props</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Metadata</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> id = params.<span class="property">productId</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">`产品 <span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">`这是产品 <span class="subst">$&#123;id&#125;</span> 的详情页`</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>同一路由 不能同时导出 metadata 对象和 generateMetadata 函数</li>
<li>客户端组件（带 “use client”）无法使用元数据 API</li>
</ol>
<h3 id="元数据合并规则"><a href="#元数据合并规则" class="headerlink" title="元数据合并规则"></a>元数据合并规则</h3><p>假设：</p>
<ul>
<li>根布局 app&#x2F;layout.tsx：<ul>
<li>export const metadata &#x3D; { title: ‘网站’ };</li>
</ul>
</li>
<li>页面 app&#x2F;about&#x2F;page.tsx：<ul>
<li>export const metadata &#x3D; { title: ‘关于我们’ };</li>
</ul>
</li>
</ul>
<p>最终页面标题为 “关于我们”，因为 页面元数据优先级更高。</p>
<hr>
<h3 id="元数据-title-字段的高级用法"><a href="#元数据-title-字段的高级用法" class="headerlink" title="元数据 title 字段的高级用法"></a>元数据 title 字段的高级用法</h3><p><strong>title 可以是 字符串 或 对象：</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Metadata</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">metadata</span>: <span class="title class_">Metadata</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;默认标题&#x27;</span>,         <span class="comment">// 没有设置时使用</span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;%s | 安全生产&#x27;</span>,   <span class="comment">// 模板格式：页面标题 | 安全生产</span></span><br><span class="line">    <span class="attr">absolute</span>: <span class="string">&#x27;&#x27;</span>,               <span class="comment">// 绝对覆盖，优先级最高</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;页面描述内容&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>静态或动态二选一</li>
<li>页面元数据优先级最高</li>
<li>元数据从根到叶子合并</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/08/11/Next-js-%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/Next-js-%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">Next.js 布局</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-11 10:29:26 / 修改时间：17:52:48" itemprop="dateCreated datePublished" datetime="2025-08-11T10:29:26+08:00">2025-08-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础布局"><a href="#基础布局" class="headerlink" title="基础布局"></a>基础布局</h2><p>布局是在应用程序的多个页面之间共享的 UI。  <strong><code>layout.tsx</code></strong> 文件会用来包裹页面的内容，它接受一个 <code>children</code> 属性，并在布局中渲染。</p>
<p><strong>根布局</strong>的示例代码：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/layout.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> metadata = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Next.js&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;Generated by Next.js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">RootLayout</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  children,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  children: React.ReactNode;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">body</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件结构示例："><a href="#文件结构示例：" class="headerlink" title="文件结构示例："></a>文件结构示例：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line"> ├─ layout.<span class="property">tsx</span>       # 根布局</span><br><span class="line"> └─ about</span><br><span class="line">     └─ page.<span class="property">tsx</span>     # about 页面</span><br></pre></td></tr></table></figure>
<p>渲染流程：<br>about&#x2F;page.tsx 内容 → app&#x2F;layout.tsx 布局中渲染</p>
<h2 id="嵌套布局"><a href="#嵌套布局" class="headerlink" title="嵌套布局"></a>嵌套布局</h2><p>如果在某个子目录（如 about）中创建一个 layout.tsx，<br>则该布局会只作用于该目录及其子路由。</p>
<p>显示层级：</p>
<p><code>about/page.tsx → about/layout.tsx → app/layout.tsx</code></p>
<p>这样可以为某些页面单独定制布局，而不影响全局。</p>
<h2 id="多个根布局"><a href="#多个根布局" class="headerlink" title="多个根布局"></a>多个根布局</h2><p>Next.js 支持 路由分组 (Route Groups) 来实现多个根布局。<br>    1.	创建一个路由分组目录（名称用括号括起来，如 (admin)）<br>    2.	在分组目录下添加自己的 layout.tsx，该布局将只作用于分组内的页面。</p>
<p>示例结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line"> ├─ (admin)</span><br><span class="line"> │   ├─ layout.tsx     # admin 专属布局</span><br><span class="line"> │   └─ dashboard</span><br><span class="line"> │       └─ page.tsx</span><br><span class="line"> └─ (shop)</span><br><span class="line">     ├─ layout.tsx     # shop 专属布局</span><br><span class="line">     └─ products</span><br><span class="line">         └─ page.tsx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样 (admin) 和 (shop) 互不干扰，各自拥有不同的根布局。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>   layout.tsx 用于定义布局，接收 children。</li>
<li>   根布局放在 app&#x2F;layout.tsx。</li>
<li>   嵌套布局放在子目录中，只影响该目录。</li>
<li>   使用路由分组可实现多个独立的根布局。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/07/28/NextJs-%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/28/NextJs-%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">Next.js 路由系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-28 19:41:39 / 修改时间：23:23:03" itemprop="dateCreated datePublished" datetime="2025-07-28T19:41:39+08:00">2025-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Next-js-路由系统（约定式路由）"><a href="#Next-js-路由系统（约定式路由）" class="headerlink" title="Next.js 路由系统（约定式路由）"></a>Next.js 路由系统（约定式路由）</h1><p>Next.js 的路由系统基于 <strong>约定大于配置</strong> 原则，开发者只需要将页面组件放在特定目录下，即可自动生成对应的路由，无需手动配置路由表。</p>
<hr>
<h2 id="路由基本约定"><a href="#路由基本约定" class="headerlink" title="路由基本约定"></a>路由基本约定</h2><ol>
<li>所有路由文件必须放在 <code>app/</code> 目录下（App Router 模式）。</li>
<li>每个<strong>文件夹</strong>表示一个 URL 路径段。</li>
<li>路由页面文件必须命名为 <code>page.tsx</code> 或 <code>page.js</code>。</li>
<li>每个页面组件将自动作为一个路由。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>app&#x2F;<br>├── page.tsx             → 路由路径 &#x2F;<br>├── about&#x2F;<br>│   └── page.tsx         → 路由路径 &#x2F;about<br>└── contact&#x2F;<br>└── page.tsx         → 路由路径 &#x2F;contact</p>
<hr>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>使用 <code>[]</code> 包裹文件夹名来创建动态路由参数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>app&#x2F;<br>└── products&#x2F;<br>└── [productId]&#x2F;<br>└── page.tsx     → 路由路径 &#x2F;products&#x2F;:productId</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// products/[productId]/page.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProductPage</span>(<span class="params">&#123; params &#125;: &#123; params: &#123; productId: <span class="built_in">string</span> &#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Product ID: &#123;params.productId&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套动态路由"><a href="#嵌套动态路由" class="headerlink" title="嵌套动态路由"></a>嵌套动态路由</h2><p>支持多级动态参数结构。<br>app&#x2F;<br>└── products&#x2F;<br>    └── [productId]&#x2F;<br>        ├── page.tsx         → <code>/products/:productId</code><br>        └── [reviewId]&#x2F;<br>            └── page.tsx     → <code>/products/:productId/:reviewId</code></p>
<h3 id="捕获所有路由段（Catch-All-Routes）"><a href="#捕获所有路由段（Catch-All-Routes）" class="headerlink" title="捕获所有路由段（Catch-All Routes）"></a>捕获所有路由段（Catch-All Routes）</h3><p>使用 […slug] 语法捕获任意数量的路径段。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>app&#x2F;<br>└── blog&#x2F;<br>    └── […slug]&#x2F;<br>        └── page.tsx         → <code>/blog/*</code> 动态匹配所有子路径</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blog/12</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">CatchAllPage</span>(<span class="params">&#123; params &#125;: &#123; params: &#123; slug: <span class="built_in">string</span>[] &#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>路径段: &#123;params.slug.join(&#x27; / &#x27;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="404-页面（Not-Found）"><a href="#404-页面（Not-Found）" class="headerlink" title="404 页面（Not Found）"></a>404 页面（Not Found）</h2><p>全局 404 页面<br>app&#x2F;not-found.tsx</p>
<p>你也可以为每个路由子目录创建局部 404 页面：<br>app&#x2F;<br>└── about&#x2F;<br>    ├── not-found.tsx<br>    └── page.tsx</p>
<p>在 not-found.tsx 中定义页面不存在时的 UI：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">NotFound</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>此页面不存在<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主动触发 404</strong><br>你可以通过 notFound() 方法主动触发 404：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; notFound &#125; <span class="keyword">from</span> <span class="string">&#x27;next/navigation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">&#123; params &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="title function_">notFound</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正常页面内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="私有文件夹（下划线命名）"><a href="#私有文件夹（下划线命名）" class="headerlink" title="私有文件夹（下划线命名）"></a>私有文件夹（下划线命名）</h2><p>使用下划线 _ 开头的文件夹（如 _components&#x2F;）不会被视为路由路径。</p>
<ul>
<li>通常用于存放共享组件、工具函数、布局模板等。</li>
<li>如果确实需要使用下划线路径（不推荐），需通过 %5f URL 编码。</li>
</ul>
<h2 id="路由分组（Route-Groups）"><a href="#路由分组（Route-Groups）" class="headerlink" title="路由分组（Route Groups）"></a>路由分组（Route Groups）</h2><p>使用 括号 () 包裹文件夹名 创建逻辑上的路由分组，不影响实际 URL 路径结构。</p>
<p>app&#x2F;<br>└── (auth)&#x2F;<br>    └── login&#x2F;<br>        └── page.tsx     → <code>/login</code></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>功能</th>
<th>语法&#x2F;文件名</th>
<th>示例路径</th>
</tr>
</thead>
<tbody><tr>
<td>静态路由</td>
<td>page.tsx</td>
<td>&#x2F;about</td>
</tr>
<tr>
<td>动态路由</td>
<td>[id]&#x2F;page.tsx</td>
<td>&#x2F;products&#x2F;123</td>
</tr>
<tr>
<td>嵌套路由</td>
<td>子目录结构</td>
<td>&#x2F;products&#x2F;123&#x2F;reviews&#x2F;1</td>
</tr>
<tr>
<td>捕获全部路由</td>
<td>[…slug]</td>
<td>&#x2F;blog&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
<tr>
<td>404 页面</td>
<td>not-found.tsx</td>
<td>&#x2F;about&#x2F;not-found.tsx</td>
</tr>
<tr>
<td>路由分组</td>
<td>(group)&#x2F;</td>
<td>&#x2F;login from (auth)&#x2F;login</td>
</tr>
<tr>
<td>私有目录</td>
<td>_components&#x2F;</td>
<td>不作为路由路径</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/" class="post-title-link" itemprop="url">微信小程序关联服务号发送模板消息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-09 17:37:03 / 修改时间：17:50:08" itemprop="dateCreated datePublished" datetime="2025-07-09T17:37:03+08:00">2025-07-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微信小程序关联服务号发送模板消息全流程"><a href="#微信小程序关联服务号发送模板消息全流程" class="headerlink" title="微信小程序关联服务号发送模板消息全流程"></a>微信小程序关联服务号发送模板消息全流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于微信小程序模板消息有行业限制，且长期模板申请门槛较高，因此在某些业务场景下，使用小程序自身模板消息并不灵活。</p>
<p>针对这种情况，可以通过“微信开放平台”关联小程序与服务号的方式，由服务号代替小程序发送模板消息，从而实现消息通知。</p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>要实现小程序与服务号的消息打通，必须完成以下认证操作：</p>
<ol>
<li><strong>微信服务号认证</strong>：费用 ¥300 &#x2F; 年；</li>
<li><strong>微信小程序认证</strong>：费用 ¥300 &#x2F; 年；</li>
<li><strong>微信开放平台认证</strong>：费用 ¥300 &#x2F; 年。</li>
</ol>
<p>⚠️ 注意：三个认证缺一不可。</p>
<h2 id="微信开放平台绑定操作"><a href="#微信开放平台绑定操作" class="headerlink" title="微信开放平台绑定操作"></a>微信开放平台绑定操作</h2><ol>
<li>登录 <a target="_blank" rel="noopener" href="https://open.weixin.qq.com/">微信开放平台</a>，完成认证；</li>
<li>在“账号管理”中，绑定你的 <strong>微信小程序</strong> 和 <strong>服务号</strong>。</li>
</ol>
<p>绑定成功后，两个账号将共享同一 <strong>UnionID</strong>，可实现用户身份互通。</p>
<p><img src="/images/WX20250709-174425@2x.png" alt="开放平台绑定示意图"></p>
<h2 id="核心流程详解"><a href="#核心流程详解" class="headerlink" title="核心流程详解"></a>核心流程详解</h2><ol>
<li>用户在<strong>小程序</strong>中登录，获取 <strong>UnionID</strong>；</li>
<li>通过 UnionID 查询对应的 <strong>服务号 openid</strong>；</li>
<li>服务号根据 openid，调用消息推送接口发送模板消息。</li>
</ol>
<p>流程图如下：</p>
<p><img src="/images/sj112sadad1.png" alt="核心流程图解"></p>
<h2 id="核心接口文档参考"><a href="#核心接口文档参考" class="headerlink" title="核心接口文档参考"></a>核心接口文档参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">微信小程序 UnionID 机制说明</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/service/api/usermanage/userinfo/api_batchuserinfo.html">微信服务号 批量获取用户基本信息接口</a></li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过微信开放平台绑定小程序与服务号，并结合 UnionID 机制，可以灵活实现小程序与服务号间的消息互通。<br>这种方式适合对消息通知有较高需求的应用场景，是微信官方推荐的解决方案之一。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/07/02/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">微信消息推送的几种方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-02 10:36:47 / 修改时间：11:44:34" itemprop="dateCreated datePublished" datetime="2025-07-02T10:36:47+08:00">2025-07-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微信消息推送的几种方式"><a href="#微信消息推送的几种方式" class="headerlink" title="微信消息推送的几种方式"></a>微信消息推送的几种方式</h1><h2 id="一、推送方式及对比"><a href="#一、推送方式及对比" class="headerlink" title="一、推送方式及对比"></a>一、推送方式及对比</h2><p>微信平台支持多种消息推送方式，主要包括以下三种：</p>
<table>
<thead>
<tr>
<th>推送方式</th>
<th>使用平台</th>
<th>消息类型</th>
<th>用户接受程度</th>
</tr>
</thead>
<tbody><tr>
<td>小程序推送</td>
<td>微信小程序</td>
<td>模板消息 &#x2F; 服务通知</td>
<td>★★★★★（强提醒）</td>
</tr>
<tr>
<td>服务号推送</td>
<td>微信服务号</td>
<td>模板消息</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>公众号推送</td>
<td>微信订阅号</td>
<td>图文消息 &#x2F; 通知</td>
<td>★★★☆☆</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>通知强提醒等级排序：服务通知 &gt; 服务号 &gt; 公众号</strong></p>
</blockquote>
<hr>
<h2 id="二、推送效果截图"><a href="#二、推送效果截图" class="headerlink" title="二、推送效果截图"></a>二、推送效果截图</h2><h3 id="1-服务通知截图"><a href="#1-服务通知截图" class="headerlink" title="1. 服务通知截图"></a>1. 服务通知截图</h3><p><img src="/images/WechatIMG406.jpg" alt="服务通知示例"></p>
<hr>
<h3 id="2-服务号通知截图"><a href="#2-服务号通知截图" class="headerlink" title="2. 服务号通知截图"></a>2. 服务号通知截图</h3><p><img src="/images/WechatIMG407.jpg" alt="服务号示例"></p>
<hr>
<h3 id="3-公众号通知截图"><a href="#3-公众号通知截图" class="headerlink" title="3. 公众号通知截图"></a>3. 公众号通知截图</h3><p><img src="/images/WechatIMG408.jpg" alt="公众号示例"></p>
<hr>
<h2 id="三、小程序消息推送说明"><a href="#三、小程序消息推送说明" class="headerlink" title="三、小程序消息推送说明"></a>三、小程序消息推送说明</h2><p>小程序支持不同类型的消息模板推送，其模板分类与使用要求如下：</p>
<h3 id="小程序模板分类说明"><a href="#小程序模板分类说明" class="headerlink" title="小程序模板分类说明"></a>小程序模板分类说明</h3><table>
<thead>
<tr>
<th>类型</th>
<th>类目要求</th>
<th>使用限制</th>
</tr>
</thead>
<tbody><tr>
<td>新版一次性订阅消息</td>
<td>仅支持电商等特定类目</td>
<td>用户订阅后可发送 1 条消息，<strong>无时间限制</strong></td>
</tr>
<tr>
<td>一次性订阅消息</td>
<td>一般类目均可使用</td>
<td>同上</td>
</tr>
<tr>
<td>长期订阅消息</td>
<td>仅限政务民生、医疗、教育等公共服务类目</td>
<td>当前使用方式未公开</td>
</tr>
<tr>
<td>设备订阅消息</td>
<td>公共服务类目，需接入硬件设备支持</td>
<td>每日对单一用户可发送 1 条消息</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <strong>说明</strong>：新版模板会优先出现在符合类目要求的小程序的公共模板库中。</p>
</blockquote>
<h3 id="模板管理界面示意图"><a href="#模板管理界面示意图" class="headerlink" title="模板管理界面示意图"></a>模板管理界面示意图</h3><p><img src="/images/subscrib.png" alt="小程序订阅模板示意"></p>
<hr>
<h3 id="小程序推送使用场景说明"><a href="#小程序推送使用场景说明" class="headerlink" title="小程序推送使用场景说明"></a>小程序推送使用场景说明</h3><ul>
<li><p><strong>基础订阅场景</strong><br>用户每完成一次订阅授权，开发者即可下发一条消息，<strong>没有时间限制</strong>。即使订阅与实际推送之间间隔很久，也不会失效。</p>
</li>
<li><p><strong>支付关联场景</strong><br>用户在小程序内完成微信支付后，开发者可基于支付订单触发<strong>服务通知</strong>，每笔订单最多可下发 <strong>3 条消息</strong>，该额度与普通订阅消息互不冲突。</p>
</li>
</ul>
<hr>
<h2 id="四、公众号消息推送说明"><a href="#四、公众号消息推送说明" class="headerlink" title="四、公众号消息推送说明"></a>四、公众号消息推送说明</h2><h3 id="公众号消息类型对比"><a href="#公众号消息类型对比" class="headerlink" title="公众号消息类型对比"></a>公众号消息类型对比</h3><table>
<thead>
<tr>
<th>公众号类型</th>
<th>模板消息支持</th>
<th>限制条件</th>
</tr>
</thead>
<tbody><tr>
<td>订阅号</td>
<td>❌ 不支持模板消息</td>
<td>仅支持图文或图文卡片消息</td>
</tr>
<tr>
<td>服务号</td>
<td>✅ 支持模板消息</td>
<td>需企业或组织认证</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 服务号每月可主动向用户推送 <strong>4 条模板消息</strong>，适合企业级服务与重要通知场景。</p>
</blockquote>
<hr>
<h2 id="五、核心流程图"><a href="#五、核心流程图" class="headerlink" title="五、核心流程图"></a>五、核心流程图</h2><p>以下为小程序&#x2F;服务号消息推送核心流程示意图：</p>
<p><img src="/images/xxts.drawio.png" alt="核心流程图"></p>
<hr>
<h2 id="六、总结对比"><a href="#六、总结对比" class="headerlink" title="六、总结对比"></a>六、总结对比</h2><table>
<thead>
<tr>
<th>项目</th>
<th>小程序订阅消息</th>
<th>服务号模板消息</th>
<th>公众号图文推送</th>
</tr>
</thead>
<tbody><tr>
<td>接收强度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>适用场景</td>
<td>支付提醒、任务提醒、系统通知等</td>
<td>用户服务通知</td>
<td>日常图文传播</td>
</tr>
<tr>
<td>限制</td>
<td>需用户主动订阅</td>
<td>企业认证</td>
<td>用户关注即可</td>
</tr>
<tr>
<td>模板多样性</td>
<td>模板需符合类目限制</td>
<td>模板较自由</td>
<td>图文内容为主</td>
</tr>
</tbody></table>
<hr>
<p>如需集成微信消息推送，请结合业务所属类目、目标用户行为和提醒紧急程度，选择最合适的推送方式，以实现更高的用户触达率和业务转化效果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2025/06/17/%E5%AE%89%E8%A3%85%20vscode%20SCSS%20IntelliSense%20%E6%8F%92%E4%BB%B6%E5%90%8E%EF%BC%8C$$%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/17/%E5%AE%89%E8%A3%85%20vscode%20SCSS%20IntelliSense%20%E6%8F%92%E4%BB%B6%E5%90%8E%EF%BC%8C$$%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">安装 vscode SCSS IntelliSense 插件后，$$符号问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-17 10:16:30 / 修改时间：10:21:48" itemprop="dateCreated datePublished" datetime="2025-06-17T10:16:30+08:00">2025-06-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ul>
<li>安装了SCSS IntelliSense ，输入 $,再选择，会多一个 $符号，如：   font-size:$$font-size-xs。有没有办法解决？</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li>终端输入命令，打开services文件夹 open &#x2F;Users&#x2F;apple&#x2F;.vscode&#x2F;extensions&#x2F;mrmlnc.vscode-scss-0.10.0&#x2F;out&#x2F;unsafe&#x2F;services</li>
<li>修改 parser.js 文件中的 findDocumentSymbols 方法</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   async function findDocumentSymbols(document, ast) &#123;</span><br><span class="line">    const symbols = ls.findDocumentSymbols(document, ast);</span><br><span class="line">    const links = await findDocumentLinks(document, ast);</span><br><span class="line">    const result = &#123;</span><br><span class="line">        functions: [],</span><br><span class="line">        imports: convertLinksToImports(links),</span><br><span class="line">        mixins: [],</span><br><span class="line">        variables: []</span><br><span class="line">    &#125;;</span><br><span class="line">    for (const symbol of symbols) &#123;</span><br><span class="line">        const position = symbol.location.range.start;</span><br><span class="line">        const offset = document.offsetAt(symbol.location.range.start);</span><br><span class="line">        if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Variable) &#123;</span><br><span class="line">            result.variables.push(&#123;</span><br><span class="line">                name: symbol.name.replace(&quot;$&quot;, &quot;&quot;), // 关键点</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                value: getVariableValue(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Method) &#123;</span><br><span class="line">            result.mixins.push(&#123;</span><br><span class="line">                name: symbol.name,</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                parameters: getMethodParameters(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (symbol.kind === vscode_css_languageservice_1.SymbolKind.Function) &#123;</span><br><span class="line">            result.functions.push(&#123;</span><br><span class="line">                name: symbol.name,</span><br><span class="line">                offset,</span><br><span class="line">                position,</span><br><span class="line">                parameters: getMethodParameters(ast, offset)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/09/26/MongoDB-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/26/MongoDB-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">MongoDB 入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-09-26 20:33:05 / 修改时间：20:40:47" itemprop="dateCreated datePublished" datetime="2024-09-26T20:33:05+08:00">2024-09-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-安装-Homebrew"><a href="#1-安装-Homebrew" class="headerlink" title="1. 安装 Homebrew"></a>1. 安装 Homebrew</h3><p>如果还没有安装 Homebrew，可以使用以下命令安装 Homebrew：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可以访问 Homebrew 的 <a target="_blank" rel="noopener" href="https://brew.sh/">官方网站</a> 了解更多信息。</p>
<h3 id="2-使用-Homebrew-安装-MongoDB"><a href="#2-使用-Homebrew-安装-MongoDB" class="headerlink" title="2. 使用 Homebrew 安装 MongoDB"></a>2. 使用 Homebrew 安装 MongoDB</h3><h4 id="a-添加-MongoDB-官方-Homebrew-Tap"><a href="#a-添加-MongoDB-官方-Homebrew-Tap" class="headerlink" title="a. 添加 MongoDB 官方 Homebrew Tap"></a>a. 添加 MongoDB 官方 Homebrew Tap</h4><p>首先，运行以下命令来添加 MongoDB 官方的 Homebrew Tap（软件源）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br></pre></td></tr></table></figure>

<h4 id="b-安装-MongoDB-社区版"><a href="#b-安装-MongoDB-社区版" class="headerlink" title="b. 安装 MongoDB 社区版"></a>b. 安装 MongoDB 社区版</h4><p>接下来，使用 Homebrew 来安装 MongoDB 社区版：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mongodb-community@6.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>@6.0</code> 是 MongoDB 的版本号，你可以根据需要替换为其他版本。</p>
</blockquote>
<h3 id="3-启动-MongoDB-服务"><a href="#3-启动-MongoDB-服务" class="headerlink" title="3. 启动 MongoDB 服务"></a>3. 启动 MongoDB 服务</h3><p>安装完成后，可以通过 Homebrew 启动 MongoDB：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start mongodb/brew/mongodb-community</span><br></pre></td></tr></table></figure>

<p>这会将 MongoDB 作为 macOS 服务启动，并且会在每次系统启动时自动启动。</p>
<p>如果你只想手动启动 MongoDB 而不让它自动运行，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure>

<h3 id="4-检查-MongoDB-是否运行"><a href="#4-检查-MongoDB-是否运行" class="headerlink" title="4. 检查 MongoDB 是否运行"></a>4. 检查 MongoDB 是否运行</h3><p>你可以运行以下命令，查看 MongoDB 服务是否已经成功启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services list</span><br></pre></td></tr></table></figure>

<p>MongoDB 的状态应该显示为 “started”。</p>
<h3 id="5-连接-MongoDB"><a href="#5-连接-MongoDB" class="headerlink" title="5. 连接 MongoDB"></a>5. 连接 MongoDB</h3><p>MongoDB 服务器启动后，你可以通过 <code>mongo</code> 命令连接到 MongoDB 的命令行工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>如果一切正常，你现在应该已经连接到 MongoDB 的 shell，可以开始使用数据库了。</p>
<h3 id="6-停止-MongoDB-服务"><a href="#6-停止-MongoDB-服务" class="headerlink" title="6. 停止 MongoDB 服务"></a>6. 停止 MongoDB 服务</h3><p>如果你需要停止 MongoDB 服务，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services stop mongodb/brew/mongodb-community</span><br></pre></td></tr></table></figure>

<hr>
<p>这样，你就可以在 Mac 上成功安装和运行 MongoDB。如果遇到任何问题，请确保 Homebrew 和 MongoDB 的安装路径正确，并查看 Homebrew 提供的安装日志。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhihuzeye.github.io/2024/06/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face1.png">
      <meta itemprop="name" content="之乎泽野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽野之乡">
      <meta itemprop="description" content="积跬步，至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 泽野之乡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">面向对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-17 21:14:25" itemprop="dateCreated datePublished" datetime="2024-06-17T21:14:25+08:00">2024-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 20:25:30" itemprop="dateModified" datetime="2024-09-26T20:25:30+08:00">2024-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="认识对象"><a href="#认识对象" class="headerlink" title="认识对象"></a>认识对象</h2><ol>
<li>认识对象<ul>
<li>对象（object） 是键值对的集合，表示属性和值的映射关系</li>
<li>对象的语法：k和v之间用冒号分割，每组k:v之间用逗号分割，最后一个k:v对后可以不书写逗号</li>
<li><strong>属性名是否加引号？：如果对象的属性名不符合JS标识符命名规范，则这个键名必须用引号包裹</strong></li>
<li><strong>属性的访问：可以用“点语法”访问对象中指定键的值，如果属性名不符合JS标识符命名规范，则必须用方括号的写法来访问；如果属性名以变量形式存储，则必须使用方括号形式</strong></li>
<li>属性的更改：直接使用赋值运算符对某属性复制即可更改属性</li>
<li>属性的创建：如果对象本身没有某个属性值，则用点语法赋值时，这个属性就会被创建出来</li>
<li>属性的删除：如果要删除某个对象的属性，则需要用delete操作符</li>
</ul>
</li>
<li>对象的方法<ul>
<li>如果某个属性值是函数，则它也被称之为对象的“方法”</li>
<li>方法也是函数，只不过方法是对象的“函数属性”，它需要对象打点使用</li>
</ul>
</li>
<li>对象的遍历<ul>
<li>和遍历数组类似，对象也可以被遍历，遍历对象需要使用 for…in….循环</li>
<li>使用 for…in…循环、Object.keys() 等 可以遍历对象每个键</li>
</ul>
</li>
<li><strong>对象的深浅克隆（面试）</strong><ul>
<li>基本类型值和引用类型值<ul>
<li>基本类型值<ul>
<li>数字、字符串、布尔、undefined、null</li>
<li>内存中产生新的副本</li>
<li>比较值是否相等</li>
</ul>
</li>
<li>引用类型值<ul>
<li>对象、数组等</li>
<li><strong>内存中不产生新的副本，而是让变量指向同一个对象</strong></li>
<li><strong>比较内存地址是否相同，即比较是否为同一对象</strong></li>
</ul>
</li>
</ul>
</li>
<li>对象也是引用类型值<ul>
<li>不能通过var obj2 &#x3D; obj1 这样的语法克隆一个对象</li>
<li>使用 &#x3D;&#x3D; 或者 &#x3D;&#x3D;&#x3D; 进行对象的比较时，比较的是它们是否为内存中的同一个对象，而不是比较值是否相同</li>
</ul>
</li>
<li>浅克隆：只克隆对象的“表层”，如果对象的某些属性值又是引用类型值，则不进行一步克隆它，而是引用它</li>
<li>对象的深克隆：克隆对象的全貌，无论对象的属性值是否又是引用类型值，都能将它们实现克隆</li>
<li>和数组的深克隆类似，对象的深克隆需要使用递归</li>
</ul>
</li>
</ol>
<h2 id="认识函数的的上下文"><a href="#认识函数的的上下文" class="headerlink" title="认识函数的的上下文"></a>认识函数的的上下文</h2><ol>
<li>什么是上下文<ul>
<li>函数的上下文：函数中可以使用 this 关键字，它表示函数的上下文</li>
<li>与中文中“这”类似，函数中的 this 具体指代什么必须通过调用函数时的“前言后语”来判断</li>
<li><strong>普通函数的上下文是调用使用才能确定的，并且规则很多，但是箭头函数的上下文是定义时候确定的。</strong></li>
<li><strong>函数的上下文由调用方式决定</strong><ul>
<li>同一个函数，用不同的形式调用他，则函数的上下文不同</li>
<li><strong>函数只有被调用的时候，它的上下文才能被确定</strong></li>
<li>函数的上下文（this关键字）由调用函数的方式决定，function是“运行时上下文”策略</li>
<li>函数如果不调用，则不能确定函数的上下文</li>
</ul>
</li>
</ul>
</li>
<li>6种上下文规则<ul>
<li><strong>规则1：对象打点调用它的方法函数，则函数的上下文是这个打点的对象</strong><ul>
<li>对象.方法()</li>
</ul>
</li>
<li><strong>规则2：圆括号直接调用函数，则函数上下文是window对象</strong><ul>
<li>函数()</li>
</ul>
</li>
<li><strong>规则3：数组（类数组对象）枚举出函数进行调用，上下文是这个数组（类数组对象）</strong><ul>
<li>数组<a href="">下标</a></li>
<li>类数组对象<ul>
<li>什么是类数组对象：所有键名为自然数序列（从0开始），且有length属性的对象</li>
<li>argument对象是最常见的类数组对象，它是函数的实参列表</li>
</ul>
</li>
</ul>
</li>
<li><strong>规则4：IIFE中的函数，上下文是window对象</strong><ul>
<li>IIFE：立即可执行函数</li>
<li><code>(function()&#123; ...  &#125;)()</code></li>
</ul>
</li>
<li><strong>规则5：定时器、延时器调用函数，上下文是window对象</strong><ul>
<li>setInterval(函数,时间)</li>
<li>setTimeout(函数,时间)</li>
</ul>
</li>
<li><strong>规则6：事件处理函数的上下文是绑定事件的DOM元素</strong><ul>
<li><code>DOM元素.onclick = function()&#123; ... &#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>call和apply (call 呼叫,打电话，apply 应用，申请)<ul>
<li>call 和 apply 能指定函数的上下文 <ul>
<li>函数.call(上下文)</li>
<li>函数.apply(上下文)</li>
</ul>
</li>
<li>call 和 apply 区别<ul>
<li>只有在函数有参数的时候才能被体现出来</li>
<li>1、call 要用逗号罗列参数 ；2、apply 要把参数写到数组中</li>
</ul>
</li>
</ul>
</li>
<li>上下文规则总结（规则&#x2F;上下文）<ul>
<li>对象.函数() <ul>
<li>对象</li>
</ul>
</li>
<li>函数()<ul>
<li>window</li>
</ul>
</li>
<li>数组<a href="">下标</a> <ul>
<li>数组</li>
</ul>
</li>
<li>IIFE<ul>
<li>window</li>
</ul>
</li>
<li>定时器、延时器<ul>
<li>window</li>
</ul>
</li>
<li>DOM事件处理函数<ul>
<li>绑定DOM的元素</li>
</ul>
</li>
<li>call 和 apply<ul>
<li>任意指定</li>
</ul>
</li>
<li>用 new 调用函数<ul>
<li>秘密创建出的对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li>用new调用函数四布走<ul>
<li>用 new 调用函数的执行步骤和它的上下文弄清楚</li>
<li><strong>JS 规定，使用new操作符调用函数会进行“四步走”：</strong><ul>
<li>1、函数体内会自动创建出一个空白对象</li>
<li>2、函数的上下文（this）会指向这个对象</li>
<li>3、函数体内的语句会执行</li>
<li>4、函数会自动返回上下文对象，即使函数没有return语句</li>
</ul>
</li>
</ul>
</li>
<li>构造函数<ul>
<li>构造函数是一种特殊类型的函数，它在创建对象时被调用。它的主要目的是初始化对象的属性和方法。在JavaScript中，构造函数通常使用关键字<code>class</code>或<code>function</code>定义，并使用<code>new</code>关键字来创建对象。构造函数可以接受参数，这些参数可以用于设置对象的属性。</li>
</ul>
</li>
<li>类和实例<ul>
<li>类好比是“蓝图”，类只描述对象会拥有哪些属性和方法，但是并不具体指明属性的值。</li>
<li>实例是具体的对象</li>
<li>JavaScript中的构造函数可以类比于OO语言中的“类”，写法的确类似，但和真正的OO语言还是有本质的不同</li>
</ul>
</li>
</ol>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ol>
<li>继承<ul>
<li>实现继承的关键在于：子类必须拥有父类的全部属性和方法，同时子类还能定义自己特有的属性和方法。</li>
<li>1、原型链继承<ul>
<li>使用方法：<ul>
<li>子类的 prototype （原型） &#x3D;  new 父类()</li>
<li><strong>让子类的构造函数的 prototype ，指向父类的一个实例</strong></li>
<li>使用 Javascript 特有的原型链特性来实现继承，是普遍的做法</li>
</ul>
</li>
<li>存在的问题：<ul>
<li>问题2：子类的构造函数中，往往需要重复定义很多超类（父类、基类）定义过的属性，即，子类的构造函数写的不够优雅</li>
<li>问题1：如果父类的属性中有引用类型值，则这个属性会被所有子类的实例共享</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>2、构造函数继承（伪造对象、经典继承）<ul>
<li>使用方法：<ul>
<li><code>Parent.call(this, name);</code></li>
</ul>
</li>
<li>存在的问题：<ul>
<li><em><strong>借用构造函数的思想非常简单：在子类构造函数的内部调用超类的构造函数，但是要注意使用 call() 绑定上下文</strong></em></li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>3、组合继承<ul>
<li>使用方法：<ul>
<li><code>Parent.call(this, name);</code></li>
<li><code>Child.prototype = new Parent();</code></li>
</ul>
</li>
<li>存在问题：<ul>
<li>将借用原型链和借用构造函数的技术组合到一起，叫做组合继承，也叫做伪经典继承</li>
<li>组合继承是 JavaScript 中最常用的继承方式</li>
<li>组合继承继承的问题：组合继承最大的问题就是无论在什么情况下，都会调用两次超类的构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数的内部</li>
<li>构造函数继承和组合继承的区别在于： - 构造函数继承通过在子类构造函数内部调用父类构造函数来实现属性的继承，但无法继承父类原型链上的方法。 - 组合继承则是结合了原型链继承和构造函数继承的优点，通过调用父类构造函数来实现属性的继承，并且通过将子类的原型指向父类的实例来继承父类的方法。</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>4、原型式继承<ul>
<li>使用方法：<ul>
<li><code>var child = Object.create(parent);</code></li>
</ul>
</li>
<li>存在问题：<ul>
<li><strong>Object.create() 方法，可以根据指定的对象为原型创建出新对象，兼容性大于IE9</strong></li>
<li>在没有必要“兴师动众”地创建构造函数，而只是想让新对象与现有对象“类似”的情况下，使用 Object.create() 即可胜任，称为原型式继承</li>
<li>Object.create() 的兼容性写法<ul>
<li>如何在低版本浏览器中实现 object.create() 呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个临时构造函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 让这个临时构造函数的 prototype 指向o，这样一来它 new 出来的对象，__prototype__ 指向了o</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">    <span class="comment">// 返回 F 的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">object</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">__proto__</span> === obj1)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">b</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">   <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>5、寄生式继承<ul>
<li>使用方法：<ul>
<li>编写一个函数，它接收一个参数o，返回以o为原型的新对象p，同时给p上添加预置的新方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;悠悠&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(o)</span><br><span class="line">    p.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，正在睡觉`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">f</span>(o1)</span><br><span class="line">p1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">88</span>)</span><br><span class="line">p1.<span class="title function_">sayHello</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">f</span>(o2)</span><br><span class="line">p2.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p2&quot;</span>,p2)</span><br></pre></td></tr></table></figure></li>
<li>寄生式继承就是编写一个函数，它可以“增强对象”，只要把对象传入这个函数，这个函数将以此对象为“基础”创建出新对象，并为新对象赋予新的预置方法</li>
<li>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式</li>
</ul>
</li>
<li>存在问题：<ul>
<li>缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，即“方法没有写到 prototype 上”</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">createChild</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">    child.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi from Child&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">createChild</span>(parent);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>6、寄生组合式继承<ul>
<li>使用方法：<ul>
<li><strong>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已，本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受两个函数，子类构造函数、父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">33</span>, <span class="number">44</span>, <span class="number">56</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello 我是&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;在睡觉&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, sex, age, no, scholl</span>) &#123;</span><br><span class="line">    <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, sex, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">no</span> = no;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scholl</span> = scholl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用我们自己写的 inheritPrototype 函数，让 Student 类的 prototype 指向以 People.prototype 为原型的一个新对象</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">People</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">study</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exam</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">14025123</span>, <span class="string">&#x27;wenzhou&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure></li>
<li>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</li>
</ul>
</li>
<li>存在问题：<ul>
<li>寄生组合式继承的主要缺点是： 1. 虽然解决了组合继承中多次调用父类构造函数的问题，但仍然会调用一次父类构造函数来创建原型。 2. 增加了代码的复杂度，相比其他继承方式，可读性较差。</li>
</ul>
</li>
<li>代码示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">   prototype.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">   <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>instanceof 运算符<ul>
<li>用来检测“某个对象”对象是不是某个类的实例</li>
<li>底层机理：检查 Student.prototype 属性是否在 xiaoming 的原型链上（多少层都是，只要在就行）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming instaceof <span class="title class_">Student</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>原型链的终点<ul>
<li><em><strong>原型链的终点是 Object.prototype。 Object.prototype 是所有 JavaScript 对象的顶层原型，它是原型链的终点。</strong></em></li>
</ul>
</li>
<li>在prototype上添加方法<ul>
<li>People.prototype.方法 &#x3D; function(){ … }</li>
</ul>
</li>
<li>prototype在原型链查找<ul>
<li><strong>Javascript规定：实例可以打点访问它的原型的属性和方法，这被称为“原型链查找”</strong></li>
<li>遮蔽效应：如果实例上已经有属性和方法，则不往原型链上查找</li>
</ul>
</li>
<li>什么是prototype？<ul>
<li>任何函数都有prototype属性，prototype是英语“原型”的意思</li>
<li>prototype 属性值是个对象，它默认拥有 constructor 属性指回函数</li>
<li><strong>普通函数的 prototype 属性没有任何用处，而构造函数的 prototype 属性非常有用</strong></li>
<li><em><strong>构造函数的 prototype 属性是它实例的原型</strong></em></li>
</ul>
</li>
<li>hasOwnProperty<ul>
<li>hasOwnProperty 方法可以检查对象是否真正“自己拥有”某属性或者方法<ul>
<li>实例.hasOwnProperty(‘属性|方法’)</li>
</ul>
</li>
</ul>
</li>
<li>in<ul>
<li>in 运算符只能检查某个属性或方法是否可以被对象访问，不能检查是否自己的属性或方法<ul>
<li>语法：’属性|方法’ in 实例</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="上升到面向对象"><a href="#上升到面向对象" class="headerlink" title="上升到面向对象"></a>上升到面向对象</h2><ol>
<li>面向对象的本质：定义不同的类，让类的实例工作</li>
<li>面向对象的优点：程序编写更清晰、代码结构更严密、使代码更健壮更利于维护</li>
<li>面向对象经常用到的场合：需要封装和复用性的场合（组件思维）</li>
</ol>
<h2 id="JS的内置对象"><a href="#JS的内置对象" class="headerlink" title="JS的内置对象"></a>JS的内置对象</h2><ol>
<li>Date对象<ul>
<li>使用 new Date() 即可得到当前时间的日期对象，它是 object 类型值</li>
<li>使用 new Date(2020,11,1) 即可得到指定日期的日期对象，注意第二个参数表示月份，从0开始算，11表示12月<ul>
<li>这种写法不算时区</li>
</ul>
</li>
<li>也可以是 new Date(‘2020-12-01’)  这样的写法，月份，日期不足两位要补零<ul>
<li>按照字符串的写法，月份不是从0开始算，12月就是12月</li>
<li>这种写法算时区，中国属于东八区</li>
</ul>
</li>
<li>日期对象的常见方法<ul>
<li>getDate() 得到日期 1 ~ 31</li>
<li>getDay()  得到星期 0 ~ 6</li>
<li>getMonth()  得到月份 0 ~ 11</li>
<li>getFullYear()  得到年份 </li>
<li>getHours()  得到小时数 0 ~ 23</li>
<li>getMinutes()  得到分钟数 0 ~ 59</li>
<li>getSeconds()  得到秒数 0 ~ 59</li>
</ul>
</li>
<li>时间戳<ul>
<li>时间戳表示1970年1月1日零点整距离某时刻的毫秒数</li>
<li>通过 getTime() 方法或者 Date.parse() 函数可以将日期对象变为时间戳<ul>
<li>getTime() 精确到毫秒</li>
<li>Date.parse() 精确到秒</li>
</ul>
</li>
<li>通过 new Date(时间戳)  的写法，可以将时间戳变为日期对象</li>
</ul>
</li>
</ul>
</li>
<li>包装类<ul>
<li>Number()、String()、Boolean() 分别是数字、字符串、布尔值的“包装类”</li>
<li>很多编程语言都有“包装类”的设计，包装类的目的就是为了让基本类型值可以从他们的构造函数的prototype上获得方法</li>
<li>Number()、String()、Boolean() 的实例都是 object 类型，它们的 PrimitiveValue 属性存储的它们本身值<ul>
<li>PrimitiveValue 属性不可以自己打点访问，它是一个内部属性值</li>
</ul>
</li>
<li>new 出来的基本类型值可以正常参与运算</li>
<li>Array 不能成为数组的包装类 ，包装类是对基本类型的面向对象封装，而 Array 本身就不是基本类型值（而是引用类型值），所以就谈不上包装了，undefined、null 是没有包装类的</li>
</ul>
</li>
<li>Math对象<ul>
<li>幂和开方<ul>
<li>Math.pow()、Math.sqrt()</li>
</ul>
</li>
<li>向上取整和向下取整<ul>
<li>Math.ceil()、Math.floor()</li>
</ul>
</li>
<li>四舍五入方法<ul>
<li>Math.round()</li>
</ul>
</li>
<li>Math.max() 和 Math.min()<ul>
<li>Math.max() 可以得到参数列表最大值</li>
<li>Math.min() 可以得到参数列表最小值</li>
<li>Math.max() 要求参数必须是“罗列出来”，而不能是数组<ul>
<li>用 ES6 展开运算符</li>
<li>Math.max.apply(null,arr)</li>
</ul>
</li>
</ul>
</li>
<li>随机数 Math.random()<ul>
<li>Math.random() 可以得到 0 ~ 1之间的小数</li>
<li>为了得到 [a，b] 区间内的整数，可以使用这个公式 <ul>
<li><code>parseInt(Math.random() * (b - a + 1))  + a</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="JS的内置构造函数"><a href="#JS的内置构造函数" class="headerlink" title="JS的内置构造函数"></a>JS的内置构造函数</h2><ol>
<li>Javascript 有很多内置构造函数，比如Array就是数组的构造函数，Function 就是函数类型的构造函数，Object 就是对象类型的构造函数<ul>
<li>任何数组的字面量都可以看做是Array的实例</li>
<li>拓展数组的求和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展求和方法</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            count += arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">sum</span>())</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>内置的构造函数非常有用，所有该类型的方法都是定义在它的内置构造函数的 prototype 上的，我们可以给这个对象添加新的方法，从而拓展某类型的功能</li>
<li>内置构造函数的关系<ul>
<li><strong>Object.prototype 是万物原型链的终点。Javascript 中函数、数组皆为对象。</strong></li>
<li>任何函数都可以看做是 Function “new 出来的”，那我们开一个脑洞：Object 也是函数呀，它是不是 Function “new 出来的呢”？答案是肯定的</li>
</ul>
</li>
</ol>
<h2 id="重点内容"><a href="#重点内容" class="headerlink" title="** *重点内容 **"></a>** *重点内容 **</h2><ol>
<li>熟悉每条函数上下文 this 的判定规则<ul>
<li><strong>函数上下文 this 取决于函数如何被调用，而不是函数如何被定义</strong></li>
</ul>
</li>
<li>call 和 apply 的功能和区别</li>
<li>用 new 调用函数的四步走</li>
<li>什么是类和实例？面向对象编程的意义</li>
<li>prototype 和原型链查找</li>
<li>继承的实例、有哪些继承的方法？</li>
<li>使用面向对象实现小案例</li>
<li>熟练掌握 Math、Date等 JS 内置对象</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">之乎泽野</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"zhihuzeye","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
